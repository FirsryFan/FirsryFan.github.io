[{"title":"学术：详解 Treap & FHQ","url":"/2025/08/09/%E5%AD%A6%E6%9C%AF%EF%BC%9A%E8%AF%A6%E8%A7%A3-Treap-FHQ/","content":"前言BST 和 Heap 都是两个可以有很多等效结构的数据结构，这种灵活性让他们具有了同时维护的可能性。而 Treap 就是这样一种结合的产物。\nTreap 有一个很方便的点：他完全分化了职责，数据处理交给 BST，平衡性交给 Heap，所以只要在平衡树旋转或者依据路径拆合的过程中，注意一下 key 值带来的顺序即可。所以这些操作不管有多么花哨，只要保证了堆性质，就可以保证一定的平衡性，而不用担心退化问题。\n本文涉及的 zig, zag, split, merge 操作都是 Cpp 语言之美的体现，传参传地址和灵活的递归让代码实现非常简洁，同时让初学者脑壳痛，难以理清楚具体的运行过程，下面进行解析。\nTreap 的旋转我们说对节点 fat 进行右旋，指的是把 fat 向右下方按到下面去，而把他的儿子 cur 提起来，放在自己的位置，下面是代码以及图解过程。\n关于左旋……右旋都会了，左旋就对代码异或一下，原理也是一样，不多废话。\n代码请注意这份代码其实并不简洁，很多地方为了方便理解而特殊设置，比如临时变量 fat 和 ancSon 这么奇怪的变量名，所以请理解之后根据自己的习惯打磨属于自己的板子。\ninline void zig(int&amp; ancSon) {  int fat = ancSon;  int cur = lson(fat);    lson(fat) = rson(cur);    rson(cur) = fat;    pushUp(fat);    pushUp(cur);    ancSon = cur;    return;}\n\n图解这是原来的树的形态（其他子树，不涉及改动，也不好看，就没有显示）：\nlson(fat) = rson(cur)，安排 rson 的后事，让 fat 来接管，满足 BST 性质，且让父子关系改变（把这种中间状态映射到父子之类的人人关系上还是太抽象了）。\n\nrson(cur) = fat，注意 rson 后改动，不然原本的 rson 就没人接管，被丢掉了。这个时候已经看到 fat, cur 已经构建成了反的父子关系。\n\n不过与 fat 产生关系的还有 fat(fat)，也就是 anc。\n这一点是比较不好从代码层面上理解的，所以这里我把传参的名字改成了 ancSon。虽然逻辑上和 fat 是一个东西，但是在存储上完全不同。ancSon = cur 的意思就是让来自 anc 的指针指向 cur，所以在后文 FHQ 的 split 操作时，我愿意把它命名为 link。不过熟悉之后就没有写成这样的必要了。\n处理了这个，逻辑上就完善了，整理一下可视化就是最后的样子。\n\n\nFHQ 的 Split &amp; MergeSplitinline void split(int p, int v, int&amp; linkA, int&amp; linkB) {    if (p == 0)        return linkA = linkB = 0, void();    if (val(p) &lt;= v) {        linkA = p;        split(rsn(p), v, rsn(p), linkB);    } else {        linkB = p;        split(lsn(p), v, linkA, lsn(p));    }    pushUp(p);    return;}\n\n先说 Split，祭上这个上课时 why 的手绘图，而我们照样去 split(13)。\n接下来是视觉盛宴，请欣赏（不要在意作图的时候一些小细节）。\n\n我们首先创建 linkA, linkB，这个时候都还是初始的，也就是 split 函数当中创建的变量。\n我们发现 10 &lt; 13，于是让 linkA 为 10 节点。\n接下来递归调用下一层，此时传入的函数参数 linkA 实际上是 10 节点的右儿子，这意味着下图的关系：10 的右儿子处于待定状态，而不再是原来的 14 节点。这个时候，我们可以保证 10 以及其左子树一定是小于 13 的，但是其右子树仍然有小于 13 节点存在的可能性，所以继续向右寻找。\nsplit(rson(p), v, rson(p), linkB)\n\n请注意，后续操作中有赋值语句更改 rson(p)，所以逻辑上 10, 14 处于断开状态，但是存储上，调用的时候的第一位 rson(p) 仍然是 14 节点。\n\n同理，当我们向右继续寻找的时候，发现 14 &gt; 13，于是让 linkB 指向 14 节点，然后向不确定的左子树继续寻找。\n\n发现 12 &lt; 13，这意味着我们的传参 linkA，其本质是 rson(10 节点)，要进行赋值语句了。\nlinkA = p;\n\n这就是下面这一步 linkA 指向 12 节点所体现的。其余的操作一致，自行理解，不再赘述。\n\n\n\n\n在这里我们继续向 13.5 的左子树走下去，发现 p == 0，意味着两棵树已经被完全分开了。我们每次借助 linkA, linkB 的传承，每一步都拆掉了一条边。在走完 10 -&gt; 14 -&gt; 12 -&gt; 13 -&gt; 13.5 的一条根到叶子的路径之后，我们就成功用 O(logN) 的时间复杂度把整棵树劈开了。此时，linkA, linkB 就指向原来留存的空节点 0 即可。\n可视化整理一下就是这个样子，很好看。根据上文，沿着一条路径剖开，其相对位置是保持不变的，所以 Tree 性质和 Heap 性质都没有被破坏掉，是非常完美的一个处理平衡树的思路。（小蒟蒻本以为旋转就是灵活性的极限了，没想到还有狠人）\nMerge关于 Merge，其实也就好理解了。这其实就是一个争儿子的过程。\ninline int merge(int linkA, int linkB) {    if (!linkA || !linkB)        return linkA + linkB;    if (key(linkA) &gt; key(linkB)) {        rsn(linkA) = merge(rsn(linkA), linkB);        pushUp(linkA);        return linkA;    } else {        lsn(linkB) = merge(linkA, lsn(linkB));        pushUp(linkB);        return linkB;    }}\n\n这里假设 val(A) &lt; val(B), key(A) &gt; key(B)。\n考虑对 rtA, rtB 进行合并。首先根据 key 值，rtA 肯定是父亲。那么问题就是合并之后 rtA 有两个可能的右儿子：rson, rtB，因为都满足 Tree 性质和 Heap 性质。所以怎么办呢，要考虑对 rson, rtB 进行合并。\n容易发现是递归处理的，因为在缝合路径上都会存在多了一个儿子的问题，直到到达叶子节点，那个时候就是我们的决策边界。我们只需要 return 一下到底谁才是最后的根，随后其他节点依次根据下方传来的判断更新即可。容易发现还是一个根到叶子的路径，仍然是 O(logn) 的复杂度。\n\n希望读完以后能够让大家有更深刻的理解。以上，感谢。\nupdate：\n由于 graph editor 的灵活性，在 linkA 接到 13 节点下方是，应该是右儿子。（它自己飘到左边去了）\n","categories":["学术","OI","Difficulty_5"],"tags":["数据结构","Treap","FHQ Treap"]},{"title":"题单：FHQ_Treap","url":"/2025/08/09/%E9%A2%98%E5%8D%95%EF%BC%9AFHQ-Treap/","content":"来源：洛谷日报 作者：万万没想到\nLevel 1 Split &amp; Merge\n P3369 【模板】普通平衡树\n P6136 【模板】普通平衡树（数据加强版）\n P2596 [ZJOI2006] 书架\n P3850 [TJOI2007] 书架\n P1110 [ZJOI2007] 报表统计\n P4309 [TJOI2013] 最长上升子序列\n P5338 [TJOI2019] 甲苯先生的滚榜\n\nLevel 2 pushUp &amp; pushDown\n P4847 银河英雄传说V2\n P1486 [NOI2004] 郁闷的出纳员\n P4146 序列终结者\n P3391 【模板】文艺平衡树\n P5217 贫穷\n\nLevel 3 可持久化\n P3835 【模板】可持久化平衡树\n P3919 【模板】可持久化线段树 1（可持久化数组）\n P5055 【模板】可持久化文艺平衡树\n P5350 序列\n P5586 [P5350] 序列 (加强版)\n\nLevel 4 更多高阶技巧\n P2042 [NOI2005] 维护数列\n P5854 【模板】笛卡尔树\n P3865 【模板】ST 表 &amp;&amp; RMQ 问题\n P3987 我永远喜欢珂朵莉~\n P5610 [Ynoi2013] 大学\n P3224 [HNOI2012] 永无乡\n P3201 [HNOI2009] 梦幻布丁\n P3285 [SCOI2014] 方伯伯的OJ\n P5066 [Ynoi Easy Round 2014] 人人本着正义之名\n CF817F MEX Queries\n P3968 [TJOI2014] 电源插排\n\n","categories":["题单","OI","Difficulty_6"],"tags":["数据结构","FHQ Treap"]},{"title":"数位 DP","url":"/2025/08/09/%E6%95%B0%E4%BD%8D-DP/","content":"部分来源：2025/07/24 SDOI_2025部分来源：个人\n\n #546. 与7无关\n #547. 与13有关\n #549. 不要 62\n P1093. [SCOI2009] windy 数\n P1090. 花神的数论题\n #551. Amount of Degrees\n #552. 数字游戏\n #553. 平衡数\n #559. 山峰数\n P1091. [ZJOI2010] 数字计数\n P6754 [BalticOI 2013] Palindrome-Free Numbers (Day1)\n P3413 SAC#1 - 萌数\n P1831 杠杆数\n\n","categories":["题单","OI","Difficulty_4"],"tags":["动态规划","数位 DP"]},{"title":"题单：二分图最大匹配","url":"/2025/08/09/%E9%A2%98%E5%8D%95%EF%BC%9A%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D/","content":"来源：2025/07/25 SDOI_2025\n\n P10937 車的放置\n P5182 棋盘覆盖\n P1407 [国家集训队] 稳定婚姻\n P10936 导弹防御塔\n P7368 [USACO05NOV] Asteroids G\n P1640 [SCOI2010] 连续攻击游戏\n P1129 [ZJOI2007] 矩阵游戏\n\n","categories":["题单","OI","Difficulty_5"],"tags":["图论","二分图","最大匹配"]},{"title":"字符串 01","url":"/2025/08/09/%E9%A2%98%E5%8D%95%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2-01/","content":"来源：2025/07/21,22 SDOI_2025\n\n P3370 【模板】字符串哈希\n P1381 单词背诵\n P9606 [CERC2019] ABB\n P3375 【模板】KMP\n P4391 [BalticOI 2009] Radio Transmission 无线传输\n P2375 [NOI2014] 动物园\n P10915 [蓝桥杯 2024 国 B] 最长回文前后缀\n P3193 [HNOI2008] GT考试\n P1470 [USACO2.3] 最长前缀 Longest Prefix\n P2580 于是他错误的点名开始了\n P4551 最长异或路径\n P3879 [TJOI2010] 阅读理解\n P2536 [AHOI2005] 病毒检测\n P2922 [USACO08DEC] Secret Message G\n P5357 【模板】AC 自动机\n P3966 [TJOI2013] 单词\n P4052 [JSOI2007] 文本生成器\n P3121 [USACO15FEB] Censoring G\n P3041 [USACO12JAN] Video Game G\n\n","categories":["题单","OI","Difficulty_5"],"tags":["字符串","哈希","KMP","字典树","AC 自动机"]},{"title":"比赛：【MX-J17】梦熊 J 组·松鼠赛","url":"/2025/08/09/%E6%AF%94%E8%B5%9B%EF%BC%9A%E3%80%90MX-J17%E3%80%91%E6%A2%A6%E7%86%8A-J-%E7%BB%84%C2%B7%E6%9D%BE%E9%BC%A0%E8%B5%9B/","content":"\n\n\n#31\nScore\nTime\n\n\n\ntotal\n370\n6.26 h\n\n\nA\n100\n3.07 min\n\n\nB\n100\n19.45 min\n\n\nC\n100\n47.68 min\n\n\nD\n60\n2.38 h\n\n\nE\n10\n2.71 h\n\n\n\n P13491 【MX-X14-T1】拼凑基因\n P13492 【MX-X14-T2】反转时光\n P13493 【MX-X14-T3】心电感应\n P13494 【MX-X14-T4】分门别类\n P13495 【MX-X14-T5】魔法卷轴\n\n","categories":["比赛","OI","Difficulty_4"]},{"title":"题单：动态规划 01","url":"/2025/08/09/%E9%A2%98%E5%8D%95%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-01/","content":"来源：2025/07/31 SDOI_2025\n\n P2014 [CTSC1997] 选课\n P1273 有线电视网\n P2018 消息传递\n P2569 [SCOI2010] 股票交易\n\n题单题解 Dynamic Programming\n“动态规划并非一种编程技巧，而是一种思考复杂多阶段决策问题的数学方法。它利用最优子结构的性质，将大问题分解为一系列相互关联的子问 题，通过递归式的贝尔曼方程实现整体最优。” —— 理查德·贝尔曼\n\n树形 DP显然的，依赖关系呈现树形结构，而这类的通用思路就是依据子树进行阶段划分。\n由于树形结构，dfs 就是我们代码实现的方式，而状态转移就在回溯阶段。我们合并统计子树带来的结果，推出当前节点为根的子树的最优子结构，然后再传回上一级，最终传给整棵树的根。 这时，f[root] 就累积了对整棵树的统计。\n所以框架是一定的，这导致状态定义的一维就是限定在以 i 为根的子树内。最重要的还是状态的描述以及转移过程。由于树形结构的特殊依赖关系，状态的转移也可以会相对复杂。\nP2014 [CTSC1997] 选课\n建立源点，把森林无代价无收益地连起来，构成一棵树；\n题意理解，发现课程 u 是代价为 1，收益为 s[u] 的物品，背包容量是 m；\n给出定义，f[u][cost] 代表以 u 为根的子树内代价为 cost 的最大收益；\n处理边界，f[u][1] 显然的就是只选择自己，为 s[u]；\n考虑转移，f[u][cost] = max(f[u][cost], f[u][cost - j] + f[v][j]；\n修订细节：\n对于 u，其更新顺序应该是 cost 从大到小，原理与 01 背包相同；\n对于 v，考虑 j &lt; cost，因为 u 必选，占用了一个名额；\n\n\n\n这道题目就做完了，整个流程格式化，而且就是背包的模版。唯一的转移限制也很显然，是一个比较合适的【模版】树上背包。\n#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 305;const int MAXM = 305;int n, m;int edgeCount;int head[MAXN], toNode[MAXN], nextEdge[MAXN];int siz[MAXN];int f[MAXN][MAXM];inline int read();inline void addEdge(int from, int to) {    edgeCount++;    toNode[edgeCount] = to;    nextEdge[edgeCount] = head[from];    head[from] = edgeCount;    return;}inline void dp(int from) {    siz[from]++;    for (int i = head[from]; i; i = nextEdge[i]) {        int to = toNode[i];        dp(to);        siz[from] += siz[to];        for (int j = m; j &gt;= 0; --j) {            int assign = (from == 0 ? j : j - 1);            assign = min(assign, siz[to]);            for (int k = 0; k &lt;= assign; ++k)                f[from][j] = max(f[from][j], f[from][j - k] + f[to][k]);        }    }}int main() {    n = read(), m = read();    for (int i = 1; i &lt;= n; ++i) {        addEdge(read(), i);        f[i][1] = read();    }    dp(0);    cout &lt;&lt; f[0][m];    return 0;}\n\nP1273 有线电视网这个题输入相对复杂一点，细心处理即可。\n主要是对于问题的转化：\n\n使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。\n\n这句话给的范围很宽，“不亏本的情况下”。我们考虑两个可能的情况 S1, S2 ，他们都做到了“尽可能多”的用户，但是 profit(S2) &gt; profit(S1)，这时选择 S2 一定不会更劣。\n换句话说，对于一个给定的观看人数 man，如果存在一个解使得电视网不亏本，那么最大利润一定不亏本。\n所以我们就去找最大利润即可。\n以上内容对于所有的动态规划题目都是一样的，难度也都在这里，想清楚了就容易了。以下是格式化的流程：\n\nf[u][man] 表示在以 u 为根的子树内让 man 个人观看的最大利润；（如果是亏损就是最小亏损，反正是金钱数量最大值）\n\nf[u][man] = max(f[u][man], f[u][man - k] + f[v][k] + weight);，这个转移显然是正确的，也是容易想到的，但是有一个时间复杂度的问题：枚举 v 是 的， 枚举 k 也是，总体上是 的，然而事实上是跑得飞快。\n\n这种做法的人还不赶快给出数据的人磕一个！Oπ\n\n\n\n其他的没什么，下面是这种方法的代码：\n#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 3005;const int INF = 0x3f3f3f3f;int n, m;int edgeCount;int head[MAXN], toNode[MAXN], nextEdge[MAXN];int weight[MAXN];int siz[MAXN];int money[MAXN];int f[MAXN][MAXN];inline void addEdge(int from, int to, int w) {    edgeCount++;    toNode[edgeCount] = to;    weight[edgeCount] = w;    nextEdge[edgeCount] = head[from];    head[from] = edgeCount;    return;}inline void dfs(int from) {    if (from &gt; n - m) {        siz[from]++;        f[from][1] = money[from];        return;    }    for (int i = head[from]; i; i = nextEdge[i]) {        int to = toNode[i];        dfs(to);        siz[from] += siz[to];        for (int j = siz[from]; j; --j)            for (int k = 0; k &lt;= siz[to]; ++k)                f[from][j] = max(f[from][j], f[to][k] + f[from][j - k] - weight[i]);    }    return;}int main() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= (n - m); ++i) {        int siz, to, w;        cin &gt;&gt; siz;        while (siz--) {            cin &gt;&gt; to &gt;&gt; w;            addEdge(i, to, w);        }    }    for (int i = (n - m + 1); i &lt;= n; ++i)        cin &gt;&gt; money[i];    for (int i = 1; i &lt;= n; ++i)        for (int j = 1; j &lt;= m; ++j)            f[i][j] = -INF;    dfs(1);        for (int i = m; i &gt;= 0; --i)        if (f[1][i] &gt;= 0)            cout &lt;&lt; i, exit(0);    return 0;}\n\n那么显然的，饱受复杂度之扰和卡常出题人之苦的我们一定要找到一个时间复杂度正确的算法！（没错，这个问题在选课的超小数据量下被隐藏了，真是可恶。）\n思路就是后序遍历。这里蒟蒻不觉得可以写得比这篇题解更好，所以就贴个链接，大家仔细阅读品鉴，并且重构自己的代码。\n这个方法好就好在他把树形结构打散了，用一种特殊的顺序，把以子树为单位合并这件事情转化到了序列上，同时是 dfs 序的通病：子树下标在一段区间内，所以还可以进行子树和非子树的 siz 跳转。（剖剖爱好者看后爽极）\n所以可以考虑重构一下以上两道题的代码，不过 T1 蒟蒻懒得重新整了，下面贴出 T2 的代码：\n不过可笑的是，应该是由于随机小数据，每次理论最差 操作还远远跑不满，这个复杂度正确的做法和原做法用时几乎一模一样。\n但是肯定有用到的时候……后序遍历法万岁！\n#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 3005;const int INF = 0x3f3f3f3f;int n, m;int mon[MAXN];int edgeCount;int head[MAXN], toNode[MAXN], nextEdge[MAXN];int countDfn;int siz[MAXN], ind[MAXN];int f[MAXN][MAXN];inline int read();inline void addEdge(int from, int to) {    edgeCount++;    toNode[edgeCount] = to;    nextEdge[edgeCount] = head[from];    head[from] = edgeCount;    return;}inline void init() {    n = read(), m = read();    for (int i = 1; i &lt;= (n - m); ++i) {        int cnt = read();        while (cnt--) {            int to = read();            mon[to] = -read();\t// 这里考虑边权下放点权            addEdge(i, to);        }    }    for (int i = (n - m + 1); i &lt;= n; ++i)        mon[i] += read();\t\t// 与刚刚下放的点权对冲    return;}inline void dfs(int from) {    siz[from]++;    for (int i = head[from]; i; i = nextEdge[i]) {        int to = toNode[i];        dfs(to);        siz[from] += siz[to];    }    countDfn++;    ind[countDfn] = from;    return;}int main() {    init();    dfs(1);    for (int i = 0; i &lt;= countDfn; ++i)        for (int j = 1; j &lt;= m; ++j)            f[i][j] = -INF;    // 注意初始化 i = 0 也要赋值，因为被依赖了    for (int i = 1; i &lt;= countDfn; ++i) {        int from = ind[i];        for (int j = 1; j &lt;= m; ++j) {            if (from &gt;= (n - m + 1))                f[i][j] = max(f[i - 1][j - 1] + mon[from], f[i - siz[from]][j]);            else                f[i][j] = max(f[i - 1][j] + mon[from], f[i - siz[from]][j]);        }    }        for (int i = m; i &gt;= 0; --i)        if (f[countDfn][i] &gt;= 0)            cout &lt;&lt; i, exit(0);    return 0;}\n\nP2018 消息传递这个题目比较奇怪，“每次传递一个”导致了其特殊性，这和普通的 Bfs 和树的重心就完全不同了。\n首先一些比较显然错误的贪心策略：最大的子树、度数最大的子树、等等。如果度数大，已经传递了的节点就可以在较长时间内持续做出贡献；如果子树大，那么大的在运行的同时还可以运行小的。所以单一的考虑是有问题的。\n回归到动态规划上来，我们要的是最优子结构，能够决定顺序的，一定是他们的结果，因为这代表了整个状态的贡献，而不是状态中的某一个特征。\n所以考虑计算出各个子树所用时间之后，按照所需时间从大到小进行传递，比较的贪心，但是贪得东西是有动态规划性的。\n格式化过程就不展示了，因为相似性过高，自己思考之后看代码也会很容易。\n下面是代码：\n#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1005;int n;int edgeCount;int head[MAXN], toNode[MAXN &lt;&lt; 1], nextEdge[MAXN &lt;&lt; 1];int f[MAXN];vector&lt;int&gt; son;int t = 0x3f3f3f3f;vector&lt;int&gt; ans;inline void addEdge(int from, int to) {    edgeCount++;    toNode[edgeCount] = to;    nextEdge[edgeCount] = head[from];    head[from] = edgeCount;    return;}inline void dfs(int from, int father) {    for (int i = head[from]; i; i = nextEdge[i]) {        int to = toNode[i];        if (to != father)            dfs(to, from);    }        for (int i = head[from]; i; i = nextEdge[i]) {        int to = toNode[i];        if (to != father)            son.push_back(to);    }    if (son.empty())        return f[from] = 1, void();        sort(son.begin(), son.end(), [](int a, int b) {        return f[a] &gt; f[b];    });    for (size_t i = 0; i &lt; son.size(); ++i)        f[from] = max(f[from], f[son[i]] + (int)i + 1);    son.clear();    return;}inline void solve() {    for (int i = 1; i &lt;= n; ++i) {        son.clear();        memset(f, 0, sizeof(f));        dfs(i, 0);        if (t &gt; f[i]) {            ans.clear();            t = f[i];            ans.push_back(i);        } else if (t == f[i])            ans.push_back(i);    }    return;}int main() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    cin &gt;&gt; n;    for (int i = 2; i &lt;= n; ++i) {        int fat;        cin &gt;&gt; fat;        addEdge(fat, i);        addEdge(i, fat);    }    solve();    cout &lt;&lt; t &lt;&lt; '\\n';    for (int i : ans)        cout &lt;&lt; i &lt;&lt; ' ';    return 0;}\n\n单调队列优化 DPP2569 股票交易读题这个题目比较麻烦，因为涉及的参数比较多，我们慢慢看。\n\n是收益最大化问题，这个应该就是我们 f[][] 所保存的东西；\n有一条时间线，这个划分了阶段，因为每一天都有属于自己的参数，我们最终的询问也是第 T 天的值；\n有很多的限制，手上最多持有的股票、一次交易（一天之内）能交易的最大的量，这个限制了我们转移的路径，在代码中的体现可能就是循环的边界以及各种 continue;\n\n状态定义这个是很显然的，f[i][j] 表示经过前 i 天，且在第 i 天手上持有 j 个股票的最大利润，而我们求的就是 f[T][j] 中的最大值。\n暴力转移这一部分时首先要理解清晰的，包括题目中的含义，类似的用法以及在 f 表中数据的指向方式。\n我们状态之间分成“变”和“不变”两种传递方式：\n\n不变，这意味着我们的初始状态或者是上一次“变”带来的影响可以延续到后续的某一天；\n变，这个可能是买入股票使持有量增加，或者是卖出股票使持有量减少。从这里可以看出，我们并不能只看持有量就能分析过程，而是要分析买入和卖出，其转移的终点不过是通过初始状态和以上两种操作计算出来的位置罢了。\n\n所以 f[day][now] 可能的更新来源就有以下几个：\n\nf[day - 1][now]，不变，和昨天一样；\nf[day - 1][k], k &lt; now，变了，买入了一些（now - k）股票；\nf[day - 1][k], k &gt; now，变了，卖出了一些股票；\n\n那有些同学就要问了：\n\n欸？之前的不是可以一直延续吗？你为什么只考虑了昨天（day - 1）？\n\n回想一下我们简化的完全背包的代码，它和 01 背包的区别在于费用维的遍历顺序。它是从小到大的：\nfor (int i = 1; i &lt;= n; ++i)    for (int j = cost[i]; j &lt;= m; ++j)        f[j] = max(f[j], f[j - cost[i]] + val[i]);\n\n这个导致了我们可以使用刚刚更新过的值再次加上 val[i] 继续得到新的值，隐式地让 i 物品被选取了多次。\n这里的道理也是一样，我们说有一种操作叫做“不变”，我们对于传递过来的东西不变，但是传递过来的东西也可以是前一个阶段不变过来的，所以我们可以只关注昨天 day - 1。我们对于每个 day 中 now 只股票的情况，都看一遍 day - 1，看看从哪天怎么转过来是最好的即可（也就是找结果的最大值）。\n这个时候我们经过了很多思考，十分满足，觉得和正解近在咫尺，不过是  和  嘛 QAQ。\n优化转移这部分我们用表格图进行演示，并且讲清楚单调队列的使用方式。\n窗口操作\n如上图所示，假如我们考虑第三天手上留有三只股票的情形。\n\n紫色箭头就是“不变”的策略，我们直接继承第二天手上就有的 3 只股票也行；\n注意到右边的小字，我们一天之内只能买卖最多 3 只股票，这意味着蓝色箭头是可行的，他们买的股票数量都不超过三只；同时橘色箭头也是可行的，因为卖了不超过 3 只。但是我们不能从 day 2, 7 的情况转移过来，因为它需要卖掉 4 只股票才能达成我们期望的状态，而这是不可行的，这就是所谓路径被限制了。\n\n\n\n这是两个对于 day 1, day 2 但是不同只股票的情况，先只考虑买入。\n绿色的点是末状态，橘色的点是可以转移到绿色点的状态，容易发现这是一个窗口，长度为三（当然可以小于三，比如只有一只股票的时候）。这意味着整个在更新的过程中，我们不必要把 day - 1 重看一遍，我们作为近视眼，在 now + 1 能够多看到的，就是 day - 1 的 now 位置，而丢掉的就是 now - lb 位置。\n这个对于卖出是一个一模一样的过程，唯一的差别在于顺序，因为卖出的窗口向下长的，所以从下向上考虑，不再赘述。\n我们每讨论完一个 now，就对应的丢掉 day - 1 的窗口末端，把 day - 1, now 加入考虑。如果，我们有一种数据结构，在完成这次更新之后还能立刻告诉我窗口内部转移结果最大值，这样子扫描过程就变成  的了！\n单调队列在经典的【模版】题目“滑动窗口”中，我们就是需要维护一个这样的数据结构。\n在这里，我们希望找到限制以内的最优解，而且当当前最优解掉到外面去的时候，我们还知道谁顶上来。俗话说的好：\n\n如果一个选手年纪比你小而且考得比你好，你就没有希望了。\n\n这句话的意思就是，他会在你的近视窗口范围内更久，给更多的未处理的点带来贡献，而且贡献还比你大，你就不会被考虑了。相信大家现在都理解为什么可以舍弃掉一部分了。\n所以单调队列就是这样的，它是一个队列，内部具有单调性。一个后加入的值 cur 如果比先加入的值 pre 要大，那 pre 就可以滚出去了，我们不需要它，它没有用处，cur 可以完美地代替它的位置，而且做得比它还好。\n我们一直这样让吊车尾滚出去，直到 cur 遇上了一个比它厉害的大牛 orz，在目前，我们的数据还是由 orz 以及 orz 前面的神犇更新的，但是当大牛和神犇退去的时候，就到了 cur 顶上来的时候了。\n这就是我对单调队列的简单介绍，如果觉得有趣但是没有用，那就去看那个模版题的题解吧。\n我们要维护什么？注意到状态转移方程：\n\nf[day][now] = max(f[pre][k] - pb[day] * (now - k));，这是买入；\nf[day][now] = max(f[pre][k] + ps[day] * (k - now));，这是卖出；\n\n学过分数线的同学都知道，分离常数或者参变分离是很有用的，我们维护数据也是如此。对于一个给定的 day, now, pre，可以认为只有 k 一个变量。所以我们把含有 k 的部分提出来：\n\nf[pre][k] + pb[day] * k，这是买入；\nf[pre][k] + ps[day] * k，这是卖出；\n\n我们只需要搞一个单调队列，把这些值和下标丢进去，然后按照标准程序走就行了：\n\n检查是否为空和队头是否合法（在考虑范围内）；\n用队头更新当前值；\n让实力不足的吊车尾滚出去；\n把当前新考虑得值加到里面去；\n\n代码#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 2005;const int INF = 0x3f3f3f3f;int T, MaxP, W;int pb[MAXN], ps[MAXN];int lb[MAXN], ls[MAXN];deque&lt;int&gt; val, ind;int f[MAXN][MAXN];inline void init() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    cin &gt;&gt; T &gt;&gt; MaxP &gt;&gt; W;    for (int i = 1; i &lt;= T; ++i)        cin &gt;&gt; pb[i] &gt;&gt; ps[i] &gt;&gt; lb[i] &gt;&gt; ls[i];    return;}int main() {    init();    for (int i = 0; i &lt;= T; ++i)        for (int j = 0; j &lt;= MaxP; ++j)            f[i][j] = -INF;    f[0][0] = 0;    for (int day = 1; day &lt;= T; ++day) {        int pre = max(0, day - W - 1);        /*--- transform through buy ---*/        val.clear();        ind.clear();        for (int now = 0; now &lt;= MaxP; ++now) {            f[day][now] = max(f[day][now], f[day - 1][now]);            while (!ind.empty() &amp;&amp; ind.front() &lt;= now - lb[day] - 1) {                ind.pop_front();                val.pop_front();            }            if (!ind.empty())                f[day][now] = max(f[day][now], val.front() - pb[day] * now);            int curVal = f[pre][now] + pb[day] * now;            while (!ind.empty() &amp;&amp; val.back() &lt;= curVal) {                ind.pop_back();                val.pop_back();            }            val.push_back(curVal);            ind.push_back(now);        }        /*--- transform through sell ---*/        if (pre != 0) {            val.clear();            ind.clear();            for (int now = MaxP; now &gt;= 0; --now) {                f[day][now] = max(f[day][now], f[day - 1][now]);                while (!ind.empty() &amp;&amp; ind.front() &gt;= now + ls[day] + 1) {                    ind.pop_front();                    val.pop_front();                }                if (!ind.empty())                    f[day][now] = max(f[day][now], val.front() - ps[day] * now);                int curVal = f[pre][now] + ps[day] * now;                while (!ind.empty() &amp;&amp; val.back() &lt;= curVal) {                    ind.pop_back();                    val.pop_back();                }                val.push_back(curVal);                ind.push_back(now);            }        }    }        int ans = 0;    for (int i = 0; i &lt;= MaxP; ++i)        ans = max(ans, f[T][i]);    cout &lt;&lt; ans;    return 0;}\n","categories":["题单","OI","Difficulty_5"],"tags":["动态规划","树形 DP","动态规划优化","单调性优化","单调队列"]},{"title":"题单：平衡树 01","url":"/2025/08/09/%E9%A2%98%E5%8D%95%EF%BC%9A%E5%B9%B3%E8%A1%A1%E6%A0%91-01/","content":"来源：2025/07/29 SDOI_2025\n\n P3369 【模板】普通平衡树\n P2234 [HNOI2002] 营业额统计\n P2286 [HNOI2004] 宠物收养场\n P1486 [NOI2004] 郁闷的出纳员\n P2042 [NOI2005] 维护数列\n\n","categories":["题单","OI","Difficulty_5"],"tags":["数据结构","Treap","FHQ Treap"]},{"title":"题单：拓扑排序","url":"/2025/08/09/%E9%A2%98%E5%8D%95%EF%BC%9A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","content":"来源：2025/07/14 SDOI_2025\n\n P2661 [NOIP 2015 提高组] 信息传递\n P1038 [NOIP 2003 提高组] 神经网络\n CF1100E Andrew and Taxi\n P3243 [HNOI2015] 菜肴制作\n P4376 [USACO18OPEN] Milking Order G\n P1983 [NOIP 2013 普及组] 车站分级\n P4017 最大食物链计数\n P1954 [NOI2010] 航空管制\n P1119 灾后重建\n P1347 排序\n P1522 [USACO2.4] 牛的旅行 Cow Tours\n\n","categories":["题单","OI","Difficulty_4"],"tags":["图论","拓扑排序"]},{"title":"题单：生成树","url":"/2025/08/09/%E9%A2%98%E5%8D%95%EF%BC%9A%E7%94%9F%E6%88%90%E6%A0%91/","content":"来源：2025/07/17 SDOI_2025\n\n P2632 Explorer\n P2916 [USACO08NOV] Cheering up the Cow G\n P1340 兽径管理\n P1550 [USACO08OCT] Watering Hole G\n P1967 [NOIP 2013 提高组] 货车运输\n AT_abc355_f [ABC355F] MST Query\n AT_abc352_e [ABC352E] Clique Connect\n CF1051F The Shortest Statement\n CF1184E1 Daleks’ Invasion (easy)\n CF1184E2 Daleks’ Invasion (medium)\n CF1184E3 Daleks’ Invasion (hard)\n P4180 [BJWC2010] 严格次小生成树\n\n","categories":["题单","OI","Difficulty_5"],"tags":["图论","生成树"]},{"title":"题单：差分","url":"/2025/08/09/%E9%A2%98%E5%8D%95%EF%BC%9A%E5%B7%AE%E5%88%86/","content":"来源：2025/07/28 SDOI_2025\n\n P3406 海底高铁\n P3368 【模板】树状数组 2\n P8165 [eJOI 2021] AddK\n P4514 上帝造题的七分钟\n P3128 [USACO15DEC] Max Flow P\n P3397 地毯\n B4161 [BCSP-X 2024 12 月小学高年级组] 操作序列\n P3948 数据结构\n P6627 [省选联考 2020 B 卷] 幸运数字\n P1600 [NOIP 2016 提高组] 天天爱跑步\n P4264 [USACO18FEB] Teleportation S\n P5268 [SNOI2017] 一个简单的询问\n P6070 『MdOI R1』Decrease\n P12716 [Algo Beat Contest 002 C] Counting Square Numbers\n P7871 「Wdoi-4」芙兰？姆Q！贤者与谜题\n\n","categories":["题单","OI","Difficulty_5"],"tags":["数据结构","差分","二维差分","树上差分","树状数组"]},{"title":"题单：最短路","url":"/2025/08/09/%E9%A2%98%E5%8D%95%EF%BC%9A%E6%9C%80%E7%9F%AD%E8%B7%AF/","content":"来源：2025/07/15 SDOI_2025\n\n P4308 [CTSC2011] 幸福路径\n P1841 [JSOI2007] 重要的城市\n P1462 通往奥格瑞玛的道路\n P2865 [USACO06NOV] Roadblocks G\n P8817 [CSP-S 2022] 假期计划\n P4568 [JLOI2011] 飞行路线\n P1266 速度限制\n P5304 [GXOI/GZOI2019] 旅行者\n P3489 [POI 2009] WIE-Hexer\n P2966 [USACO09DEC] Cow Toll Paths G\n\n","categories":["题单","OI","Difficulty_6"],"tags":["图论","最短路"]},{"title":"题单：连通性","url":"/2025/08/09/%E9%A2%98%E5%8D%95%EF%BC%9A%E8%BF%9E%E9%80%9A%E6%80%A7/","content":"来源：2025/08/01 SDOI_2025\n\n P3367 【模板】并查集\n P1197 [JSOI2008] 星球大战\n P9869 [NOIP2023] 三值逻辑\n P5787 二分图 /【模板】线段树分治\n P2863 [USACO06JAN] The Cow Prom S\n P12760 [POI 2018 R2] 自行车道 Bike paths\n P5058 [ZJOI2004] 嗅探器\n UVA610 Street Directions\n P4171 [JSOI2010] 满汉全席\n P3469 [POI 2008] BLO-Blockade\n P4616 [COCI 2017/2018 #5] Pictionary\n P2515 [HAOI2010] 软件安装\n\n","categories":["题单","OI","Difficulty_5"],"tags":["数据结构","图论","并查集","Tarjan","2-SAT"]},{"title":"题解：#A1005. 流水面条","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9A-A1005-%E6%B5%81%E6%B0%B4%E9%9D%A2%E6%9D%A1/","content":"\n使得该路径上的节点加上一个非负值，且该值单调不上升。\n\n注意到一定有解，因为非负值可以取零，所以单点修改是可行的。\n对于一个节点 ，它的子节点  代表的子树上的情况一定是互不干扰的，因为  是所有  的 ，所以已经处理的  以下的部分是独立的。\n同时  对  的贡献是累加性的。如果以  代表让以  为根的子树符合要求的最小操作次数，那么有 ，这个  的贡献是一定会有的。对于  节点也可能产生新的贡献： 的时候，需要单独对于  节点（或者他的祖先）进行一次新的操作，并且将操作后的值赋得最大。\n贪心地进行考虑，我们让子节点加到的位置尽可能地大，那么更有可能满足  的需求。如果比  更大了怎么办？在之前操作的时候在  位置把数值进行突变，总可以在子树情况不变的时候让  的值落在 。这个照应到写代码的时候就是取  操作，这是略去了“操作突变”这个细节的等效结果，对于  的祖先来说。\n为什么在合法的时候不让 ？因为这个会增加操作次数，因为求的是 ，这个是划不来的。\n总结一下：\n\n多测不清空，爆零两行泪；\n十年  一场空，不开 long long 见祖宗 ；\n对于叶子节点进行初始化；\n求出子节点给的合贡献；\n如果子节点不能满足当前的需求，那么对于当前节点单独给贡献，并且更新最大值；\n如果子节点的值的和大过了上限，说明之前一系列突变操作让  回到 ；\n\n代码：\n#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int MAXN = 200005;int t, n, st, ed;int edgeCount;int head[MAXN], toNode[MAXN], nextEdge[MAXN];LL l[MAXN], r[MAXN], f[MAXN], maxVal[MAXN];inline int read() {    int x = 0;    char ch = getchar();    while (!isdigit(ch))        ch = getchar();    while (isdigit(ch)) {        x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);        ch = getchar();    }    return x;}inline void addEdge(int from, int to) {    edgeCount++;    toNode[edgeCount] = to;    nextEdge[edgeCount] = head[from];    head[from] = edgeCount;    return;}inline void dfs(int from) {    bool isLeaf = true;    for (int i = head[from]; i; i = nextEdge[i]) {        isLeaf = false;        dfs(toNode[i]);        maxVal[from] += maxVal[toNode[i]];        f[from] += f[toNode[i]];    }    if (isLeaf)        f[from] = 1, maxVal[from] = r[from];    if (maxVal[from] &lt; l[from])        f[from]++, maxVal[from] = r[from];    maxVal[from] = min(maxVal[from], r[from]);    return;}int main() {    t = read();    while (t--) {        n = read();        st = ed + 1, ed = ed + n;        for (int i = st + 1; i &lt;= ed; ++i)            addEdge(st - 1 + read(), i);        for (int i = st; i &lt;= ed; ++i)            l[i] = read(), r[i] = read();        dfs(st);        cout &lt;&lt; f[st] &lt;&lt; '\\n';    }    return 0;}\n","categories":["题解","OI","Difficulty_5"],"tags":["动态规划","图论","树形 DP","贪心"]},{"title":"题解：P10933 创世纪","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP10933-%E5%88%9B%E4%B8%96%E7%BA%AA/","content":"本文重点讲解一下思路中比较容易卡顿的位置。状态转移方程这篇题解有着详细的讲解，从推导到优化，这里就不赘述了。\n反向建边我们反向建立边，也就是建立  的边，表示  限制 ，这样的好处是一棵外向树，每个节点有一个入度和多个出度，符合正常人的习惯。\n这还带来一个好处，就是链式前向星不需要开二倍空间了，而在删去边的部分也不用考虑双向边带来的麻烦。\n 式返祖找环如下图所示，例如我们从  号节点开始向上跳，则路径是：注意建边是反向建边，返祖就是逆流而上： 。我们在返祖的过程中用  数组标记走过的点，则遇到一个标记过的点就是环上的一端，而此时的位置就是另一端。还是很显然的，因为不会经过自己的儿子，所以这一定是一条逆向的返祖边。\n这个方法非常高效，不需要遍历整棵树，而且只需要知道  信息就可以了。不过一般不会直接告诉  信息，导致适用范围并不是非常广泛。\n\n基环树处理方式的选择我们对于基环树的处理无非两种：\n\n删去一条边，当作树进行处理，然后特殊统计删去的边对结果的影响；\n分成环上问题以及树上问题（环上节点的子树）。\n\n这个地方显然用第二种是不方便的，这样状态转移方程考虑的非常多。包括子树根节点的选或不选，环上节点的选或不选，以及多种多样的依赖关系。\n使用第一种方法就很简单了，因为有“强制”策略的存在。\n动态规划的强制策略我们在城市环路中认识了通过赋值为  做到在状态转移中强制不选取，而这个地方是另一种方法：两次树形动态规划。分别统计依赖非删去边以及依赖删去边。\n以上图为例，我们从  开始向上找到的环边的两端分别是 ，我们从  开始进行树上动态规划。\n\n依赖非删去边：删去边  之后，节点  不能够依赖于 ，结果是选取  的情况中，必有  中的一个不被选取。而这个时候  节点是否被选取都不重要，统计答案 。\n依赖删去边：现在  的选取一定依赖于  的不选取，答案就是 ，而这个时候  的子节点可以任选。\n\n删去边的方式仍然以上图为例：只要一条边指向的  节点不是起点 ，说明这条边就不是删去边，就可以正常处理。\n代码一个小的细节是，vector&lt;bool&gt; 有着极大的优化，几乎等同于 bitset，非常好用。\n#include&lt;bits/stdc++.h&gt;inline int read() {    int x = 0;    char ch = getchar();    while (!isdigit(ch))        ch = getchar();    while (isdigit(ch))        x = x * 10 + ch - '0', ch = getchar();    return x;}using namespace std;const int INF = 0x3f3f3f3f;const int MAXN = 1000005;int n, ans;int lt, rt;int edgeCount;int head[MAXN], toNode[MAXN], nextEdge[MAXN];vector&lt;bool&gt; vis;int control[MAXN];int fTree[MAXN][2];inline void addEdge(int from, int to) {    edgeCount++;    toNode[edgeCount] = to;    nextEdge[edgeCount] = head[from];    head[from] = edgeCount;    return;}int dpTree(int from, bool isDelete) {    fTree[from][0] = fTree[from][1] = 0;    vis[from] = true;    int gap = INF;    for (int i = head[from]; i; i = nextEdge[i]) {        int to = toNode[i];        if (to ^ lt) {            vis[to] = true;            int res = dpTree(to, isDelete);            fTree[from][0] += res;            gap = min(gap, res - fTree[to][0]);        }    }    fTree[from][1] = fTree[from][0] + 1 - gap;    if (!isDelete &amp;&amp; from == rt)        fTree[from][1] += gap;    return max(fTree[from][0], fTree[from][1]);}int main() {    n = read();    vis.resize(n + 1, false);    for (int i = 1; i &lt;= n; ++i)        addEdge(control[i] = read(), i);    for (int i = 1; i &lt;= n; ++i)        if (!vis[i]) {            for (lt = i; !vis[control[lt]]; vis[lt] = true)                lt = control[lt];            rt = control[lt];            int max1 = dpTree(lt, true);            dpTree(lt, false);            int max2 = fTree[lt][0];            ans += max(max1, max2);        }    cout &lt;&lt; ans;    return 0;}\n\n闲话本人在校测中使用的方法就是分成环和树，结果打了  行代码，刚好多了  行，并且直到比赛结束都没能调试成功。使用了骗分大法，输出每棵基环树结点个数的一半，竟然得了  分。\n","categories":["题解","OI","Difficulty_5"],"tags":["动态规划","图论","树形 DP","基环树"]},{"title":"题解：B4161 [BCSP-X 2024 12 月小学高年级组] 操作序列","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AB4161-BCSP-X-2024-12-%E6%9C%88%E5%B0%8F%E5%AD%A6%E9%AB%98%E5%B9%B4%E7%BA%A7%E7%BB%84-%E6%93%8D%E4%BD%9C%E5%BA%8F%E5%88%97/","content":"这种题最大的特征就是关系层层叠叠，运算依赖区间，很复杂，要一层一层算。\n题目中有几个区间 / 序列：\n\n长度为  的数据序列 ；\n长度为  的操作序列 ；\n长度为  的操作区间 ；按照  去完成对应  的部分，最终作用在  上，而我们求的就是最终的 。\n\n接下来请带上你的注意力：\n\n注意到，对于值为  的不管乘多少次都是 ，所以可以考虑转化乘法操作为改变加法操作次数；\n注意到，对 ，当且仅当 ，有  中的乘法操作会增加  中的操作次数；\n注意到，对 ，当且仅当，有乘法操作  增加  的操作次数；\n\n所以思路就清晰了：\n\n对于操作区间之间的贡献，进行倒序处理，累计其进行的乘法的个数：\n\n对于 ，每个操作都会继承上一个操作区间的影响；\n对于 ， 带来的影响就是  中乘法操作;\n\n综合以上两点，考虑：\n\n用差分维护乘法操作个数， 维护区间之间的影响；\n用前缀和维护  的乘法操作总个数，用于  计算结果；\n\n\n对于操作区间内的贡献，总的  完成倒序扫描：\n\n结合上述维护的区间之间的影响，不断累乘，计算出每个加法  的操作次数；\n同时根据  加到数据序列  上，得到答案；\n\n\n\n代码如下：\n#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int MAXN = 200005;const LL mod = 10000;int n, m, q;LL seq[MAXN];bitset&lt;MAXN&gt; optType;LL ind[MAXN], val[MAXN];LL mulCntSum[MAXN];LL cntDif[MAXN];LL l[MAXN], r[MAXN];inline LL read() {    LL x = 0;    char ch = getchar();    while (!isdigit(ch))        ch = getchar();    while (isdigit(ch)) {        x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);        ch = getchar();    }    return x;}inline void init() {    n = read(), m = read(), q = read();    for (int i = 1; i &lt;= m; ++i) {        optType[i] = (read() &amp; 1);        if (optType[i]) {            ind[i] = read();            val[i] = read();        }    }    for (int i = 1; i &lt;= q; ++i) {        l[i] = read();        r[i] = read();    }    return;}inline LL Pow(int base, int t) {    LL res = 1;    while (t) {        if (t &amp; 1)            res = (res * base) % mod;        base = (base * base) % mod;        t &gt;&gt;= 1;    }    return res;}inline void calcPrefixSum() {    for (int i = 1; i &lt;= m; ++i) {        mulCntSum[i] = mulCntSum[i - 1];        if (!optType[i])            mulCntSum[i]++;    }    return;}inline void calcRangeDif() {    LL cur = 1;    for (int i = q; i &gt;= 1; --i) {        cntDif[r[i]] = (cntDif[r[i]] + cur) % mod;        cur = (cur * Pow(2, mulCntSum[r[i]] - mulCntSum[l[i] - 1])) % mod;        cntDif[l[i] - 1] = (cntDif[l[i] - 1] - cur + mod) % mod;    }    return;}inline void calcOptToSeq() {    LL optCnt = 0;    for (int i = m; i &gt;= 1; --i) {        optCnt = (optCnt + cntDif[i]) % mod;        if (optType[i])            seq[ind[i]] = (seq[ind[i]] + optCnt * val[i]) % mod;        else            optCnt = (optCnt &lt;&lt; 1) % mod;    }    return;}int main() {    init();    calcPrefixSum();    calcRangeDif();    calcOptToSeq();    for (int i = 1; i &lt;= n; ++i)        cout &lt;&lt; seq[i] &lt;&lt; ' ';    return 0;}\n","categories":["题解","OI","Difficulty_4"],"tags":["数据结构","差分"]},{"title":"题解：P10936 导弹防御塔","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP10936-%E5%AF%BC%E5%BC%B9%E9%98%B2%E5%BE%A1%E5%A1%94/","content":"为什么是二分图？注意到一个小怪会被一个导弹秒了，但是一个防御塔是可以输出多枚导弹的，这个时候一一对应的关系被隐藏了，本质上其实是导弹和小怪的二分图，而攻击问题就转化成了匹配问题。\n怎么描述问题？注意到一次导弹攻击可以用如下的方法唯一确定：导弹  在  时刻开始从防御塔起飞，打向  小怪。由于我们知道 ，是可以计算出消灭这个小怪的结束时间的。\n所以点的描述就很清晰了，一边是导弹，另一边是小怪，维护以上信息：下标、起飞时间。\n为什么二分答案？但是又注意到另一个问题：权值。简单的最大匹配只能处理个数而不能处理权值，这就涉及最优解问题转可行性问题，这正是二分答案的重要作用。\n怎么建图？因为目标是检测可行性，说明在时间限制  以内的边是可以连的，否则不可以。\n则思路就是：对于防御塔 ，枚举第  发导弹，攻击小怪 ，计算这个过程的时间，如果在  以内，就连边。（这里邻接表会方便一点，下文实现采取这个方式）\n好的，在现在这个图上跑最大匹配，看看是否能够连  条边，毕竟一个边秒一个小怪。\n注意单位。#include&lt;bits/stdc++.h&gt;#define dwb doubleusing namespace std;const int MAXN = 55;const dwb eps = 1e-7;dwb n, m, t1, t2, v;dwb tx[MAXN], ty[MAXN];dwb mx[MAXN], my[MAXN];int nodeCnt;vector&lt;int&gt; edge[MAXN * MAXN];int match[MAXN];bool vis[MAXN];inline dwb calDist(dwb x1_, dwb y1_, dwb x2_, dwb y2_) {    return sqrt((x1_ - x2_) * (x1_ - x2_) + (y1_ - y2_) * (y1_ - y2_));}inline void reset() {    nodeCnt = 0;    for (int i = 1; i &lt;= n * m; ++i)        edge[i].clear();    memset(match, 0, sizeof(match));    return;}inline void build(dwb TLE) {    for (int i = 1; i &lt;= n; ++i)        for (int k = 0; k &lt; m; ++k) {            dwb fireTime = t1 + (dwb)k * (t1 + t2);            if (fireTime &gt; TLE)                break;            nodeCnt++;            for (int j = 1; j &lt;= m; ++j) {                dwb flyTime = calDist(tx[i], ty[i], mx[j], my[j]) / v;                if (fireTime + flyTime &lt;= TLE)                    edge[nodeCnt].push_back(j);            }        }    return;}inline bool dfs(int from) {    for (int to : edge[from]) {        if (vis[to])\tcontinue;        vis[to] = true;        if (!match[to] || dfs(match[to])) {            match[to] = from;            return true;        }    }    return false;}inline bool check(dwb TLE) {    reset();    build(TLE);    int res = 0;    for (int from = 1; from &lt;= nodeCnt; ++from) {        memset(vis, 0, sizeof(vis));        if (dfs(from))            res++;    }    return res == m;}int main() {    scanf(\"%lf%lf%lf%lf%lf\", &amp;n, &amp;m, &amp;t1, &amp;t2, &amp;v);    t1 /= 60.0;    for (int i = 1; i &lt;= m; ++i)        scanf(\"%lf%lf\", &amp;mx[i], &amp;my[i]);    for (int i = 1; i &lt;= n; ++i)        scanf(\"%lf%lf\", &amp;tx[i], &amp;ty[i]);    dwb l = 0, r = 1e6;    while (r - l &gt; eps) {        dwb mid = l + (r - l) / 2;        check(mid) ? r = mid : l = mid;    }    printf(\"%.6lf\\n\", l);    return 0;}\n","categories":["题解","OI","Difficulty_6"],"tags":["图论","二分图","最大匹配","建模","基础算法","二分答案"]},{"title":"题解：P10953 逃不掉的路","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP10953-%E9%80%83%E4%B8%8D%E6%8E%89%E7%9A%84%E8%B7%AF/","content":"边双+树剖求 前情提要本篇题解不讲解边双以及树剖的具体过程，如有需要，请移步两篇大佬的题解：\n树链剖分求 LCA\t边双连通分量\n题目分析\n从 a 城到 b 城不管怎么走，总有一些逃不掉的必经之路。\n\n很显然的是一个边双连通分量中的边一定不是“必经之路”，因为删除这条路也可以走出去，所以可以通过  求解边双连通分量进行缩点操作，考虑对于剩下的无向无环图进行处理。而无向无环图这个名字我们是不熟悉的，我们熟悉的是——树。\n所以问题转化为树上两个点之间求解必经之路。这个在树上就一目了然：求 ，两个结点之间经过  的路径上的路就是必经之路，其个数也就是边权为  的最短路了，用深度之差的方法，不必多言。\n所以代码的结构就出来了：\n\n原图的建立；\n 求边双连通分量；\n缩点建立无向无环图（树）；\n进行树剖；\n用  的方法解决树上两点距离问题。\n\n上代码：\n#include&lt;bits/stdc++.h&gt;inline int read() {    int x = 0, f = 1;    char ch = getchar();    while (ch &lt; '0' || ch &gt; '9') {        if (ch == '-')            f = -1;        ch = getchar();    }    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9')        x = x * 10 + ch - '0', ch = getchar();    return x * f;}using namespace std;const int MAXN = 100005;const int MAXM = 200005;int n, m, q;int edgeCount = 1;int head[MAXN], toNode[MAXM &lt;&lt; 1], nextEdge[MAXM &lt;&lt; 1], fromNode[MAXM &lt;&lt; 1];int countDfn;int dfn[MAXN];int ECC;stack&lt;int&gt; dfsStack;int low[MAXN], belong[MAXN];int newEdgeCount;int newHead[MAXN], newToNode[MAXM &lt;&lt; 1], newNextEdge[MAXM &lt;&lt; 1];int siz[MAXN], dep[MAXN], fat[MAXN];int son[MAXN], top[MAXN];void add(int from, int to) {    edgeCount++;    toNode[edgeCount] = to;    fromNode[edgeCount] = from;    nextEdge[edgeCount] = head[from];    head[from] = edgeCount;    return;}void in() {    int a, b;    n = read(), m = read();    for (int i = 1; i &lt;= m; ++i) {        a = read(), b = read();        add(a, b), add(b, a);    }    q = read();    return;}void tarjan(int from, int fromEdge) {    countDfn++;    dfn[from] = low[from] = countDfn;    dfsStack.push(from);    for (int i = head[from]; i; i = nextEdge[i]) {        int to = toNode[i];        if (!dfn[to]) {            tarjan(to, i);            low[from] = min(low[from], low[to]);        } else if (i != (fromEdge ^ 1))            low[from] = min(low[from], dfn[to]);    }    if (dfn[from] == low[from]) {        ECC++;        belong[from] = ECC;        while (dfsStack.top() != from) {            belong[dfsStack.top()] = ECC;            dfsStack.pop();        }        dfsStack.pop();    }    return;}void newAdd(int from, int to) {    newEdgeCount++;    newToNode[newEdgeCount] = to;    newNextEdge[newEdgeCount] = newHead[from];    newHead[from] = newEdgeCount;    return;}void newIn() {    for (int i = 2; i &lt;= (m &lt;&lt; 1); i += 2) {        int from = fromNode[i], to = toNode[i];        if (belong[from] ^ belong[to]) {            newAdd(belong[from], belong[to]);            newAdd(belong[to], belong[from]);        }    }    return;}void dfs1(int from, int father) {    siz[from]++;    fat[from] = father;    dep[from] = dep[father] + 1;    for (int i = newHead[from]; i; i = newNextEdge[i]) {        int to = newToNode[i];        if (to != father) {            dfs1(to, from);            siz[from] += siz[to];            if (siz[son[from]] &lt; siz[to])                son[from] = to;        }    }    return;}void dfs2(int from, int curTop) {    top[from] = curTop;    if (!son[from])        return;    dfs2(son[from], curTop);    for (int i = newHead[from]; i; i = newNextEdge[i]) {        int to = newToNode[i];        if (to != fat[from] &amp;&amp; to != son[from])            dfs2(to, to);    }    return;}inline int lca(int a, int b) {    while (top[a] != top[b]) {        if (dep[top[a]] &lt; dep[top[b]])            swap(a, b);        a = fat[top[a]];    }    return dep[a] &lt; dep[b] ? a : b;}int main() {    int a, b, anc;    in();    tarjan(1, 0);    newIn();    dfs1(1, 0);    dfs2(1, 1);    while (q--) {        a = belong[read()], b = belong[read()];        anc = lca(a, b);        cout &lt;&lt; dep[a] + dep[b] - (dep[anc] &lt;&lt; 1) &lt;&lt; '\\n';    }    return 0;}\n\n闲话这道题是本蒟蒻第一次拿下 Luogu.com.cn 最优解（至少截至 04-05 21:36:15）并在 0:48:49 的用时内不看题解怒切 提高+/省选-。这是 AC 记录\n","categories":["题解","OI","Difficulty_5"],"tags":["图论","Tarjan","连通性","LCA"]},{"title":"题解：P1099 [NOIP 2007 提高组] 树网的核","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP1099-NOIP-2007-%E6%8F%90%E9%AB%98%E7%BB%84-%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/","content":"题解 P1099 【树网的核】一、题意\n设  是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称  为树网（treenetwork）。\n\n\n其实是一个无根树，从哪里开始找树的直径都可以。\n保证边权为正整数，这个极其关键，在后面的推论中有用到。\n关于  其实并不重要，只是为了严谨性。\n\n\n路径：树网中任何两结点 ， 都存在唯一的一条简单路径，用  表示以  为端点的路径的长度，它是该路径上各边长度之和。我们称  为  两结点间的距离。,  为路径  上的结点。\n\n\n存在唯一简单路径，也就是说一棵树非常标准，不会有重边。而只有一条路，方便了求最后的偏心距。\n对于  比较简单，在后面其他的定义中看得懂就行了。\n 这个比较毒瘤，指的是一条路径  上各个节点  到某一节点  的距离的最小值。也就是说把这条路径看作一个整体（分量）， 其实就是  到这个节点的最短距离。\n\n\n树网的直径：树网中最长的路径成为树网的直径。对于给定的树网 ，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。\n\n\n这句话也就是树的直径的定义（他不会希望不知道算法的 OIer 能够现场推出树的直径的算法吧？）。\n那个证明挺有意思，在求出树网的核的时候有用。\n\n\n偏心距 ：树网  中距路径  最远的结点到路径  的距离，即\n\n对于给定的树网  和非负整数 ，求一个路径 ，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 （可以等于 ），使偏心距  最小。我们称这个路径为树网  的核（Core）。必要时， 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。\n\n\n树网的核首先是一段路径，他有他的长度，也有它包含的节点。\n这段路径在树网的直径上，长度小于等于要求的长度 。把他的节点看成一个集合，然后看树上其他的节点到这段路的最短距离的最大值。树的直径的不同子路可能会有不同的 ，而 core 就是在不同的路径中让  最小的那么 一条 / 多条 / 某个节点。\n最小偏心距唯一可以保证唯一，因为如果不唯一，更小的那一个所在路径就是核，而其他的就不是。\n\n二、推论\nstO StudyingFather %%%%\n\n这部分题解主要是针对 StudyingFather 题解当中 分析 部分的 定理引理证明 的更加通俗化的描述，也会有不同的证明方法，建议也去他的题解中看看数学语言描述的证明。如果有看不懂或者发现证明不严谨的，欢迎在评论区发言，本蒟蒻会及时更正。\n为了简洁以及易懂，以下证明过程中用的是简化的树，只画出了关键的路径以及节点。下文中  的形式代表  到  之间的路径的长度，类似于线段的表示方式。图片中也有比较简洁的证明过程，可以考虑优先看图。大部分的证明都是通过反证法，而反证的一个重点就是推出原本设定的直径在该情况下并不是真正的直径，从而推出矛盾。推荐同学们自己推一推。\n\n引理 1：对于一棵所有边权均为正的树，如果其存在多条直径，则树上必存在一点 p，使得所有直径均经过该点（简单来说，所有直径必交于至少一点）。\n\n\n这个还是很显然的，即使 、 是两条直径各自的中点（当然这个后面我们也会证明处理其不可能），也有在正权树上   之间的距离可以保证比所谓 “直径” 更长，也就出现了矛盾，反证法证明成立。\n\n定理 1：对于一棵所有边权均为正的树，如果其存在多条直径，则各直径的中点（不一定恰好是某个节点，可能在某条边的内部）是唯一的。\n\n\n这个证明建立在 引理 1 的基础上。首先有两条直径，假设为  和 ，则  的长度和  的长度是一致的，否则仅有长度较长的那一条直径。其次有交点 ，则有在两条直径上找到一条形如  的路径。如果说中点不重合而交点位置是重合的，则有在两直径交点的两侧长度是不同的。如图所示，蓝笔标注的中点偏向于一侧。然后通过 ，访问两个比直径一半更长的部分，会得到一个比  更长的路径，那么直径的假设就被推翻了。\n\n引理 2.1：若两条直径有重叠的部分，则于重叠部分同一端点引出的两条直径的非重叠的部分的长度相等。\n\n\n这个的证明和 定理 1 的证明非常相似。如果说 ，则有 ，那么就可以找到一条  比直径  更长的路径，而这个推翻了直径的假设。\n\n 引理 2.2：若路径存在不位于直径上的部分，这条路径对应的偏心距一定不会比全部位于直径上的路径的偏心距的最小值更小。\n\n\n这一段证明还是写的比较详细的，而从这个定理开始就不是很好证明了。这里用的不是反证法，而是找到了一个存在。其中只有蓝色的部分是直径，红色部分是一个  来源的可能。如果说  并不是直径的一部分，则有  的路径比  的路径更短。 来源于直径，那么不在直径上的部分并不会影响结果，所以有  点和  一整段路径的作用是一致的。\n这里是一个经典的错误，也是我最开始只有 70 分的原因：贪心的只去找直径上的距离其实是有问题的。如果说  则有整个直径是一个核，这个时候用贪心的策略 ，处理方法在解法部分讲解。  \n\n定理 2：设在所有满足长度限制的路径中，取得最小偏心距的路径得到的偏心距为 ，则对于任意一条直径，都存在一条长度不超过  的路径 ，使得 =。\n\n\n定理 2 推出之后，可以不用处理多条直径，因为对于任意一条直径都有答案。首先是这里有多条直径，由 引理 2.2 可以得到答案来源于直径上，而包含直径的重合部分一定会是更好的情况，也就是说没有哪一条直径会有单独的更好的选择，所以只用处理一条直径了。\n三、代码对于贪心策略错误的问题，我们找到每个节点不经过当前找到的直径上节点能够到达的最远的距离。方法其实就是标记直径上的节点“已访问”，然后通过跑一遍深搜，保存在  数组里面。\n这里借鉴的是小蓝书的最优解。其他部分在其他题解中有详细的讲解，这里就不赘述了。\n#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 300 + 5;struct Edge {    int to, weight;    Edge(int to = 0, int weight = 0) {        this-&gt;to = to;        this-&gt;weight = weight;    }};int n, s;vector&lt;Edge&gt; e[MAXN];int c;int dep[MAXN], f[MAXN];int cnt;int dia[MAXN], pres[MAXN], posts[MAXN];bool vis[MAXN];void in() {    int from, to, weight;    scanf(\"%d%d\", &amp;n, &amp;s);    for (int i = 1; i &lt; n; i++) {        scanf(\"%d%d%d\", &amp;from, &amp;to, &amp;weight);        e[from].emplace_back(to, weight);        e[to].emplace_back(from, weight);    }    return;}void dfs(int from, int fa) {    f[from] = fa;    for (auto edge : e[from]) {        if (edge.to == fa || vis[edge.to])            continue;        dep[edge.to] = dep[from] + edge.weight;        if (dep[edge.to] &gt; dep[c])             c = edge.to;        dfs(edge.to, from);    }    return;}void get_diameter() {    dfs(1, 0);    dep[c] = 0;    dfs(c, 0);    for (int from = c; from; from = f[from]) {        cnt++;        dia[cnt] = from;        pres[cnt] = dep[from];    }    reverse(dia + 1, dia + cnt + 1);    reverse(pres + 1, pres + cnt + 1);    for (int i = cnt; i &gt; 0; i--)        posts[i] = pres[cnt] - pres[i];    return;}void solve() {    for (int i = 1; i &lt;= cnt; i++)        vis[dia[i]] = true;    int maxD = 0;    for (int i = 1; i &lt;= cnt; i++) {        dep[dia[i]] = 0, c = 0;        dfs(dia[i], 0);        maxD = max(dep[c], maxD);    }    int minECC = 1 &lt;&lt; 30;    for (int l = 1, r = 1; l &lt;= cnt; l++) {        while (r &lt;= cnt &amp;&amp; pres[r + 1] - pres[l] &lt;= s)            r++;        minECC = min(max(maxD, max(pres[l], posts[r])), minECC);    }    cout &lt;&lt; minECC;    return;}int main() {    in();    get_diameter();    solve();    return 0;}\n","categories":["题解","OI","Difficulty_6"],"tags":["图论","单调性优化","树的直径","数学","离散数学"]},{"title":"题解：P12385 [蓝桥杯 2023 省 Python B] 异或和","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP12385-%E8%93%9D%E6%A1%A5%E6%9D%AF-2023-%E7%9C%81-Python-B-%E5%BC%82%E6%88%96%E5%92%8C/","content":"树状数组 + dfs 序操作如此简单，信息如此单一，为何不进精简？\n首先这个题并不需要完成链的操作，而只需要完成子树操作，所以只需要保存  两个信息即可，也就不需要完整的树剖，一遍深搜直接带走；\n其次关于树状数组的单点覆盖，可以分成抵消原来的值以及加上当前的值，对于维护和的就是加减法，对于维护异或和的，就是对于两个值分别异或一下，之前的异或没了，现在的异或进去。\n对于树转链的新手来说，注意进行修改、查询的时候一定一定一定代入的是  而不是 ！\n#include&lt;bits/stdc++.h&gt;#define lowbit(x) (x &amp; (-x))using namespace std;const int MAXN = 100005;int n, m;int edgeCount;int head[MAXN], toNode[MAXN &lt;&lt; 1], nextEdge[MAXN &lt;&lt; 1];int countDfn, dfn[MAXN], siz[MAXN], val[MAXN];int bit[MAXN];inline void addEdge(int from, int to) {    edgeCount++;    toNode[edgeCount] = to;    nextEdge[edgeCount] = head[from];    head[from] = edgeCount;    return;}inline void changeBit(int pos, int val) {    for (int i = pos; i &lt;= n; i += lowbit(i))        bit[i] ^= val;    return;}inline int queryBit(int l, int r) {    int res1 = 0, res2 = 0;    for (int i = l - 1; i; i -= lowbit(i))        res1 ^= bit[i];    for (int i = r; i; i -= lowbit(i))        res2 ^= bit[i];    return res1 ^ res2;}inline void dfs(int from, int father) {    siz[from]++;    countDfn++;    dfn[from] = countDfn;    for (int i = head[from]; i; i = nextEdge[i]) {        int to = toNode[i];        if (to != father) {            dfs(to, from);            siz[from] += siz[to];        }    }    return;}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; ++i)        scanf(\"%d\", &amp;val[i]);    for (int i = 1; i &lt; n; ++i) {        int from, to;        scanf(\"%d%d\", &amp;from, &amp;to);        addEdge(from, to), addEdge(to, from);    }    dfs(1, 0);    for (int i = 1; i &lt;= n; ++i)        changeBit(dfn[i], val[i]);    while (m--) {        int opt, pos, curVal;        scanf(\"%d%d\", &amp;opt, &amp;pos);        if (opt == 1) {            scanf(\"%d\", &amp;curVal);            changeBit(dfn[pos], val[pos]);            changeBit(dfn[pos], curVal);            val[pos] = curVal;        } else            cout &lt;&lt; queryBit(dfn[pos], dfn[pos] + siz[pos] - 1) &lt;&lt; '\\n';    }    return 0;}\n","categories":["题解","OI","Difficulty_4"],"tags":["数据结构","图论","树状数组","树链剖分","dfs 序"]},{"title":"题解：P12397 「FAOI-R9」函数大师","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP12397-%E3%80%8CFAOI-R9%E3%80%8D%E5%87%BD%E6%95%B0%E5%A4%A7%E5%B8%88/","content":"题目大意给定一个正整数函数：\n\n 表示  的十进制数字之和；\n，；\n。\n\n对于固定的 ，有  个查询，每次给定 ，求满足  的正整数  的个数。\n函数分析\n数字和上界：对于 ，.\n数根 ：\n；\n，且对任意 ，（数根）。\n\n\n\n由此， 至多包含如下四种项：\n\n；\n；\n；\n对于 ，还要加上  个 ，即 。\n\n分类讨论记 ，。\n情况 1：\n只要 ，唯一解 ，答案为 1，否则为 0。\n情况 2：\n枚举 ，令 ，检查  且  即可。\n情况 3：\n枚举 ，令\n\n检查  且  即可。\n情况 4：\n枚举：\n\n数根 ；\n\n数字和 ；\n\n令并校验 。\n\n\n每次枚举  的步长为 9，总共  次，共  次检查。\n时间复杂度对每个查询最多做  次常数级检查， 时总计  次，C++ 可在 1s 内完成。\n代码#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll T, k, m;inline ll read() {    ll x = 0;    char ch = getchar();    while (!isdigit(ch))        ch = getchar();    while (isdigit(ch)) {        x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);        ch = getchar();    }    return x;}inline int digitSum(ll x) {    int s = 0;    while (x)        s += x % 10, x /= 10;    return s;}int digitalRoot(ll x) {    return digitSum(digitSum(digitSum(x)));}inline ll k0() {    return (m &gt;= 1 ? 1 : 0);}inline ll k1() {    ll res = 0;    for (int t = 1; t &lt;= 171 &amp;&amp; t &lt; m; t++)        if (digitSum(m - t) == t)            res++;    return res;}inline ll k2() {    ll res = 0;    for (int t = 1; t &lt;= 171; t++) {        ll x = m - t - digitSum(t);        if (x &gt;= 1 &amp;&amp; digitSum(x) == t)            res++;    }    return res;}inline ll k3() {    ll res = 0;    for (int d = 1; d &lt;= 9; d++) {        ll base = m - (k - 2LL) * d;        for (int t = d; t &lt;= 171; t += 9) {            ll x = base - t - digitSum(t);            if (x &lt; 1)                break;            if (digitSum(x) == t &amp;&amp; digitalRoot(x) == d)                res++;        }    }    return res;}int main() {    T = read(), k = read();    while (T--) {        m = read();        if (k == 0)            cout &lt;&lt; k0() &lt;&lt; '\\n';        else if (k == 1)            cout &lt;&lt; k1() &lt;&lt; '\\n';        else if (k == 2)            cout &lt;&lt; k2() &lt;&lt; '\\n';        else            cout &lt;&lt; k3() &lt;&lt; '\\n';    }    return 0;}\n","categories":["题解","OI","Difficulty_5"],"tags":["数学","Ad-hoc","分类讨论","枚举"]},{"title":"题解：P12396 「FAOI-R9」平民上篮","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP12396-%E3%80%8CFAOI-R9%E3%80%8D%E5%B9%B3%E6%B0%91%E4%B8%8A%E7%AF%AE/","content":"幸好中考体考选的是排球……\n思路这个题耐心的分类讨论即可，如下：\n\n在已有的操作序列当中，需要统计的有：\n\n已经花掉的时间；\n已经完成的组数；\n每个时间的状态，便于处理下一个状态或者补充新的操作序列。\n\n其中状态可以分为是否在篮下，是否投进，失败了几次。\n注意在新的一轮 G 的时候对于是否投进以及失败次数进行重置；判定是否完成一组的时候是在 B 的同时检查是否投进以及失败次数。\n\n在补充新的序列的时候，考虑两个阶段：\n\n上一组没有完成的部分，此时会在篮下，进行分类讨论：\n\n对于已经完成了  组、已经投进和已经失败不少于三次的情况，我们并不需要讨论新的投篮，可以直接回来；\n否则，我们考虑一次投进以及补充剩下失败次数哪个花费更短；\n\n一番操作之后，总组数增加一，容易看出这么做，对于不足四个组的合理，对于不少于四个组的也没有影响。\n\n对于新开的几个组，考虑需要多少个组（不会少于零个），以及每个组选择投进还是失败三次，相乘再与答案相加即可。\n\n\n\n\n杂言G，B，A，W， 个人认为对应是 Go，Back，AC，WA，所以变量名直接一通乱搞。\n代码#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;ll a, b, c;string s;ll ans = 0;ll setCount = 0;ll WACount = 0;bool isUnderBasket = false;bool isAC = false;int main() {    scanf(\"%lld%lld%lld\", &amp;a, &amp;b, &amp;c);    cin &gt;&gt; s;    for (char ch : s) {        if (ch == 'G') {            ans += a;            isUnderBasket = true;            WACount = 0;            isAC = false;        } else if (ch == 'W')            ans += c, WACount++;        else if (ch == 'A')            ans += b, isAC = true;        else if (ch == 'B') {            ans += a;            isUnderBasket = false;            if (isAC || WACount &gt;= 3)                setCount++;        }    }    if (isUnderBasket) {        if (setCount &lt; 4 &amp;&amp; !(isAC || WACount &gt;= 3)) {            ll timeAC = b;            ll timeWA = (3 - WACount) * c;            ans += min(timeAC, timeWA);        }        ans += a;        isUnderBasket = false;        setCount++;    }    ll setNeed = max(0LL, 4 - setCount);    ll setTime = min(2 * a + b, 2 * a + 3 * c);    ans += setNeed * setTime;    cout &lt;&lt; ans;    return 0;}\n","categories":["题解","OI","Difficulty_2"],"tags":["基础算法","分类讨论","模拟"]},{"title":"题解：P13492 【MX-X14-T2】反转时光","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP13492-%E3%80%90MX-X14-T2%E3%80%91%E5%8F%8D%E8%BD%AC%E6%97%B6%E5%85%89/","content":"注意到与单调递增子段数量有关；\n注意到 k = 3 的时候可以把序列分成左右无关段和中间反转段；\n注意到冒泡排序就是中间反转段为  长度的算法；\n所以 ans = min(cnt, 3)。\n","categories":["题解","OI","Difficulty_2"],"tags":["基础算法","Ad-hoc","冒泡排序"]},{"title":"题解：P12817 [NERC 2021] Deletive Editing","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP12817-NERC-2021-Deletive-Editing/","content":"P12817 [NERC 2021] Deletive Editing\nDaisy 从单词中删除该字母的第一次出现，她是否能够从给定的初始单词出发，通过玩若干轮（包括零轮）这个游戏，最终得到她想要的单词。\n\n\n不在  内的字母可以任意依次删去，此时得到一个只含有想要单词内字母的字符串 。\n对于 ，唯一的操作是从前向后删去字母，所以找到的结果  一定是在结尾。所以让  逐个末位相比对，匹配的就在  中进行 pop_back 操作，更新当前任务为次末尾字符。\n如果在从后向前扫描 时，一个在  中出现了的字母却并不在  的末尾，是不合法的。即使前面出现了 ，也会因为当前字符出现在后面无法删除。\n\n用题干中的例子：deTeRMinEd,determinEd，很好理解了。\n所以就两点：存在，按序。实现的时候并不会去构造  字符串，只要代入  查找一下即可。\n代码如下：\n#include&lt;bits/stdc++.h&gt;using namespace std;int n;string s, t, tmp;inline bool check(string str, char ch) {    for (char c : str)        if (c == ch)            return true;    return false;}int main() {    scanf(\"%d\", &amp;n);    while (n--) {        bool flag = true;        cin &gt;&gt; s &gt;&gt; t, tmp.clear();        for (int i = s.size() - 1; i &gt;= 0; --i)            if (check(t, s[i])) {                if (t.back() == s[i])                    t.pop_back();                else                    flag = false, i = -1;            }        if (flag &amp;&amp; t.empty())            puts(\"YES\");        else            puts(\"NO\");    }    return 0;}\n\n花絮：qaq 编辑字符串也是 edit。\n","categories":["题解","OI","Difficulty_3"],"tags":["Ad-hoc"]},{"title":"题解：P13239 「2.48sOI R1」化妆品","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP13239-%E3%80%8C2-48sOI-R1%E3%80%8D%E5%8C%96%E5%A6%86%E5%93%81/","content":"最开始想着使用两个不同结构体重载排序的 deque 进行维护，然后使用二分法定位进行删除，但是发现删除仍然是  的，不可行。本蒟蒻不会写平衡树，但是会打 tag。发现如果用 used 数组进行标记每一份是否被使用，然后在从 deque 首尾取出数据时判断没有被使用过的，那么总共添加的时间复杂度应为  的，完全可以承受。最终时间复杂度为 ，瓶颈在于排序。\n#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;struct itemFas {    int f, b, ind;    bool operator &lt; (const itemFas another) const {        return f &lt; another.f;    }};struct itemBea {    int f, b, ind;    bool operator &lt; (const itemBea another) const {        return b &lt; another.b;    }};int n, m, q;vector&lt;bool&gt; used;deque&lt;itemBea&gt; bea;deque&lt;itemFas&gt; fas;LL f1, b1, f2, b2;inline int read() {    int x = 0;    char ch = getchar();    while (!isdigit(ch))        ch = getchar();    while (isdigit(ch)) {        x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);        ch = getchar();    }    return x;}int main() {    n = read();    m = n &lt;&lt; 1;    used.resize(m);    bea.resize(m);    fas.resize(m);    for (int i = 0; i &lt; m; ++i)        fas[i].f = bea[i].f = read();    for (int i = 0; i &lt; m; ++i)        fas[i].b = bea[i].b = read();    for (int i = 0; i &lt; m; ++i)        fas[i].ind = bea[i].ind = i;    sort(bea.begin(), bea.end());    sort(fas.begin(), fas.end());    while (n--) {        int opt = read();        if (opt == 1) {            while (!fas.empty() &amp;&amp; used[fas.back().ind])                fas.pop_back();            f1 += fas.back().f;            b1 += fas.back().b;            used[fas.back().ind] = true;            fas.pop_back();            while (!fas.empty() &amp;&amp; used[fas.front().ind])                fas.pop_front();            f2 += fas.front().f;            b2 += fas.front().b;            used[fas.front().ind] = true;            fas.pop_front();        } else {            while (!bea.empty() &amp;&amp; used[bea.back().ind])                bea.pop_back();            f1 += bea.back().f;            b1 += bea.back().b;            used[bea.back().ind] = true;            bea.pop_back();            while (!bea.empty() &amp;&amp; used[bea.front().ind])                bea.pop_front();            f2 += bea.front().f;            b2 += bea.front().b;            used[bea.front().ind] = true;            bea.pop_front();        }    }    cout &lt;&lt; f1 &lt;&lt; ' ' &lt;&lt; b1 &lt;&lt; '\\n' &lt;&lt; f2 &lt;&lt; ' ' &lt;&lt; b2;    return 0;}\n","categories":["题解","OI","Difficulty_3"],"tags":["基础算法","二分","延迟标记"]},{"title":"题解：P13493 【MX-X14-T3】心电感应","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP13493-%E3%80%90MX-X14-T3%E3%80%91%E5%BF%83%E7%94%B5%E6%84%9F%E5%BA%94/","content":"题意描述对于给定的  个长度为  的序列，使用最小的  次询问区分  序列与其他序列，求 ，无解输出 。\n考场二分 + 暴力思路，直接 dfs 走起！\n所以思路是：\n\n如果 n == 1，特判掉，不用问；\n枚举每一个序列，并求出区分他的答案；\n注意到具有单调性，小  可行大  就一定可行，考虑二分答案 ；\n对于给定  进行 dfs 暴力枚举，看看对于特征  问或不问是否能够区分  个（初始化自己能够区分自己）；\n\n总复杂度 ，可以通过这道题目（实际上跑得飞快）。\n#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 25;int n, m;int a[MAXN][MAXN];int man;bitset&lt;MAXN&gt; differ;inline bool dfs(int ind, int rest) {    if (rest == 0 || ind == m + 1)        return (int)differ.count() == n;    bool res = false;    res = res || dfs(ind + 1, rest);    bitset&lt;MAXN&gt; tmp = differ;    for (int i = 1; i &lt;= n; ++i) {        if (a[i][ind] != a[man][ind])            differ[i] = true;    }    res = res || dfs(ind + 1, rest - 1);    differ = tmp;    return res;}int main() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; ++i)        for (int j = 1; j &lt;= m; ++j)            scanf(\"%d\", &amp;a[i][j]);    if (n == 1)        cout &lt;&lt; 0, exit(0);    for (man = 1; man &lt;= n; ++man) {        differ.reset();        differ[man] = true;        int l = 1, r = m + 1;        while (l &lt; r) {            int mid = l + ((r - l) &gt;&gt; 1);            dfs(1, mid) ? r = mid : l = mid + 1;        }        cout &lt;&lt; (l == m + 1 ? -1 : l) &lt;&lt; ' ';    }    return 0;}\n","categories":["题解","OI","Difficulty_4"],"tags":["基础算法","二分答案","深度优先搜素"]},{"title":"题解：P13594 『GTOI - 1A』Bath","url":"/2025/08/09/%E9%A2%98%E8%A7%A3%EF%BC%9AP13594-%E3%80%8EGTOI-1A%E3%80%8FBath/","content":"贪！给我狠狠的贪！考场思路：\n\n如果存在最小合法调温次数 ，则当前调温次数 在最优策略下一定也合法。 故考虑二分答案转化为可行性问题，即如何判断是否合法。\n\n然后发现自己像只春猪，既然都有办法弄出最优策略了，在检测的同时记录一下次数即可，为什么非得套个二分答案？\n操作如下：\n\n合并同一时间的调节温度结果 ；\n扫描时区间 记录操作 时，当前时刻之前可能的水温区间；\n对于时刻 ，不调温就必须能找到温度 使得：\n不调温，下一次水温区间就是交集部分；要调温，下一次水温区间与之前无关，重置最大范围 ；\n\n正确性很显然：\n\n不存在一个交集为空却不用调温的情况；\n目前可行调温没有意义，因为上次调温可取任意值，导致当前值落在区间内任意位置；\n\n复杂度\nmap 合并 。（时间瓶颈在这里，看来二分答案亏得不多 QAQ）\n顺序扫描一次：。\n\n记得开 long long。\n\n    Folding Code \n    \n      #include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;LL n, s, L, R;LL a, x;map&lt;int, LL&gt; delt;LL ans;int main() {    ios_base::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    cin &gt;&gt; n &gt;&gt; s &gt;&gt; L &gt;&gt; R;    for (int i = 0; i &lt; n; ++i) {        cin &gt;&gt; a &gt;&gt; x;        delt[a] += x;    }    LL curL = s, curR = s;    for (auto&amp; t : delt) {        LL newL = max({curL, L, L - t.second});        LL newR = min({curR, R, R - t.second});        if (newL &lt;= newR) {            curL = newL + t.second;            curR = newR + t.second;        } else {            ans++;            curL = L;            curR = R;        }    }    cout &lt;&lt; ans;    return 0;}\n\n    \n  \n","categories":["题解","OI","Difficulty_2"],"tags":["贪心","基础算法"]},{"title":"题解：P2602 [ZJOI2010] 数字计数","url":"/2025/08/09/%E9%A2%98%E8%A7%A3%EF%BC%9AP2602-ZJOI2010-%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0/","content":"这个题一眼小学奥数，为什么要用数位 dp？\n注意到：\n\n百位数字一定时十位数字  出现次数为 ；\n十位数字一定时个位数字  出现次数为 ；\n则有 \n\n所以可以用  表示权重倍率，然后用相同的方法处理数字每一位，最后结果用  进行放缩即可。\n注意到相关限制来自三个原数字位置：，也就是高位、当前和低位上的数字。设考虑在当前位置上填入数字  ，有以下限制：\n\nif (d &lt; cur)，则可以随便填，对于更高位上可能数字 ，都有  可以选择，而对应的以  为最高位的个数又是 ，则有 ans[d] += (pre + 1) * scale；\nif (d == cur)，那么在更高位可能数字  的时候，包含当前位的较低位数字个数就变成了  个（包含后缀零），则有 ans[d] += pre * scale + suf + 1；\nif (d &gt; cur)，那么更高位数字  而较低位数字也不会有限制，则有 ans[d] += pre * scale；\n\n关于前导零，显然只有最高位会担心这个事情，且此时后缀数字随意填充，所以减去其对应的  即可。\n基于此，我方代码如下：\n#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;LL n, m;LL ans1[10], ans2[10];inline void calc(LL num, LL *ans) {    if (num &lt;= 0)        return;    for (LL scale = 1; scale &lt;= num; scale *= 10) {        LL cur = (num / scale) % 10;        LL pre = num / (scale * 10);        LL suf = num % scale;        for (int d = 0; d &lt;= 9; ++d) {            if (d &lt; cur)                ans[d] += (pre + 1) * scale;            else if (d == cur)                ans[d] += pre * scale + suf + 1;            else                ans[d] += pre * scale;            if (d == 0)                ans[d] -= scale;        }    }}int main() {    scanf(\"%lld%lld\", &amp;n, &amp;m);    calc(m, ans2);    calc(n - 1, ans1);    for (int i = 0; i &lt;= 9; ++i)        printf(\"%lld \", ans2[i] - ans1[i]);    return 0;}\n\n","categories":["题解","OI","Difficulty_4"],"tags":["动态规划","数位 DP","Ad-hoc"]},{"title":"题解：P2632 Explorer","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP2632-Explorer/","content":"人类智慧蒟蒻太弱了，准高二了还不会用直线解析式算垂足，所以就用玄学连边 A 了。\n注意到主要矛盾是优化建边，边的数量又是 Kruskal 的命根子，所以我们只连可能比较有用的边。\n观察到两条直线 ， 上面的点在  上的垂足是有单调性的，所以充分发扬人类智慧，设置大小为  的观察窗口以及大小为  的连边窗口，用于找到最优点，并且在最优点附近（可能有用的点）进行连边。\n细节处理\n为了保证从一端看向另一端，我们需要 sort 一下 t 数组；\nKruskal 一定是连成一棵树之后 edgeCount = n + m - 1 就 break；\n时间空间都很极限，我们的匹配点 match 从数组优化为两个滚动变量 pre, match；\n观察需要比较大，但是连边不是；（本蒟蒻大量的 MLE 来自这一点没有考虑到 qwq）\ndouble 保证高精，不要管为什么 #define dwb double，因为是彩蛋；\n\nupd：AddRange = 5, SeeRange = 50 既可通过此题，更多的极限数据测试已经没脸再交了 qwq。\n代码如下：\n#include&lt;bits/stdc++.h&gt;#define dwb doubleusing namespace std;const int AddRange = 15;const int SeeRange = 108;const int MAXN = 100055;const dwb INF = 1e18;struct Edge {    int from, to;    dwb weight;    bool operator &lt; (const Edge another) const {        return weight &lt; another.weight;    }};int n, m;int px[5], py[5];dwb t1[MAXN], t2[MAXN];dwb x1_, y1_, x2_, y2_;int anc[MAXN &lt;&lt; 1];vector&lt;Edge&gt; edge;inline void AncInit(int siz) {    for (int i = 1; i &lt;= siz; ++i)        anc[i] = i;    return;}inline int findAnc(int cur) {    if (cur != anc[cur])        anc[cur] = findAnc(anc[cur]);    return anc[cur];}inline void merge(int a, int b) {    anc[findAnc(a)] = findAnc(b);}inline dwb calX(dwb t, int p1, int p2) {    return px[p1] * t + px[p2] * (1 - t);}inline dwb calY(dwb t, int p1, int p2) {    return py[p1] * t + py[p2] * (1 - t);}inline dwb calDis() {    return sqrt((x1_ - x2_) * (x1_ - x2_) + (y1_ - y2_) * (y1_ - y2_));}inline void kruskal() {    dwb mst = 0;    sort(edge.begin(), edge.end());    AncInit(n + m);    int edgeCount = 0, aim = n + m - 1;    for (Edge e : edge) {        int ancFrom = findAnc(e.from);        int ancTo = findAnc(e.to);        if (ancFrom != ancTo) {            merge(ancFrom, ancTo);            mst += e.weight;            edgeCount++;            if (edgeCount == aim)                break;        }    }    printf(\"%.3lf\", mst);}inline void init() {    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= 4; ++i)        scanf(\"%d%d\", &amp;px[i], &amp;py[i]);    for (int i = 1; i &lt;= n; ++i)        scanf(\"%lf\", &amp;t1[i]);    for (int i = 1; i &lt;= m; ++i)        scanf(\"%lf\", &amp;t2[i]);    sort(t1 + 1, t1 + 1 + n);    sort(t2 + 1, t2 + 1 + m);    for (int i = 2; i &lt;= n; ++i) {        x1_ = calX(t1[i - 1], 1, 2);        y1_ = calY(t1[i - 1], 1, 2);        x2_ = calX(t1[i], 1, 2);        y2_ = calY(t1[i], 1, 2);        edge.push_back({i - 1, i, calDis()});    }    for (int i = 2; i &lt;= m; ++i) {        x1_ = calX(t2[i - 1], 3, 4);        y1_ = calY(t2[i - 1], 3, 4);        x2_ = calX(t2[i], 3, 4);        y2_ = calY(t2[i], 3, 4);        edge.push_back({i - 1 + n, i + n, calDis()});    }}inline void build() {    int pre = 1, st = 1, ed = m;    for (int i = 1; i &lt;= n; ++i) {        x1_ = calX(t1[i], 1, 2);        y1_ = calY(t1[i], 1, 2);        if (i != 1) {            st = max(1, pre - SeeRange);            ed = min(m, pre + SeeRange);        }        dwb minDis = INF;        int match = st;        for (int j = st; j &lt;= ed; ++j) {            x2_ = calX(t2[j], 3, 4);            y2_ = calY(t2[j], 3, 4);            dwb dis = calDis();            if (dis &lt; minDis)                minDis = dis, match = j;        }        pre = match;        int add_st = max(1, match - AddRange);        int add_ed = min(m, match + AddRange);        for (int j = add_st; j &lt;= add_ed; ++j) {            x2_ = calX(t2[j], 3, 4);            y2_ = calY(t2[j], 3, 4);            edge.push_back({i, j + n, calDis()});        }    }}int main() {    init();    build();    kruskal();    return 0;}\n","categories":["题解","OI","Difficulty_5"],"tags":["图论","单调性优化","生成树","数学","优化建图","人类智慧","平面几何"]},{"title":"题解：P4912 帕秋莉的魔法","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP4912-%E5%B8%95%E7%A7%8B%E8%8E%89%E7%9A%84%E9%AD%94%E6%B3%95/","content":"本题是处理 含有负值的01背包 的【模板】\n题目翻译：\n 个物品， 的初始资金，对于每个物品  有  的花费与  的收益，而且我们只能按照输入的先后顺序选择物品，并且对于每次选择物品，会获得  的增益，一并加在价值当中。\n我们显然可以用  唯一确定一种状态：考虑前  个物品时，用  的代价得到的最大收益表示为 。这个只要是做了背包的同学都没有问题。(应该没有人把水紫当成 采药 来做吧)\n每个物品只有选或不选两种可能。不选则保持原状态。选则考虑从谁转移而来。题目要求按输入的顺序，所以在第  个的时候可以考虑  的情况，我们用变量  实现枚举。所以  可以由  得来，而  所以得到如下状态转移方程：\n 。\n重点来了：处理负数 。\n由于 冰冷昂贵入云涉水的 Cpp 语言不支持数组下标为负，所以使用平移的方式转正，平移的量取决于最小的负值： ，所以设 :\nint mov 1. 转移边界。本身边界在 $f_{0,0}$ 位置，表示 没有物品没有花费 的情况，应该初始化为 $0$，但现在平移了 $mov$，所以 $f_{0,mov}=0$。2. 循环条件。现在把 $mov$ 看成零，因为 $cost$ $value$ $w$ $m$ 都有可能是负值，所以我们必须考虑很小到很大的值。在转移中有 $j-cost_i$ 这一步，所以 $j&gt;=cost_i$ 这是起码的。$j$ 的最大值就是当 $m==2500$  的时候可以取到 $(mov&lt;&lt;1)+1$ 的值。所以调的最久的   ```for(int j=cost[i];j&lt;=(mov&lt;&lt;1)+1;++j)```    已经考虑完毕了。3. 初始化以及输出。状态转移中使用了 $\\max(f_{1,j},...$ ，所以 $f_{i,j}$ 必须初始化为一个极小值，个人喜欢   ```const ll INF = 0x3f3f3f3f3f3f3f3f``` ,   但其实不开 *龙龙*  用 `int` 都没有关系。输出的时候我们要找的是所有花费为 $m+mov$ 的情况中收益最高的，所以用 `ans=-INF` 然后遍历即可。那么本篇题解就...**还没完呢！小子！**在循环条件中有一个必不可少的句子：`if(f[k][j-cost[i]]!=-INF)` 为什么？因为他此时依靠的$f_{k,j-cost_i}$ 必须是有意义的。他可能后来被 $f_{0,mov}$ 间接地赋上有意义的值，但是此时他的 ```-INF``` 并不是可以利用的，所以要排除掉。（本蒟蒻在这里 WA了两三次 ... ）顺带提一下，虽然用 vector 又慢又要手动处理边界，但是 vector 提供的 .at(i) 数组访问形式，在功能上和 [i] 一致，并且在数组越界的时候可以抛出异常，在 Run Time Error 的时候值得一试。```c++#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll mov = 2501;const ll INF = 0x3f3f3f3f3f3f3f3f;ll n, m;vector&lt;ll&gt; cost, value;vector&lt;vector&lt;ll&gt;&gt; w, f;void in() {    scanf(\"%lld%lld\", &amp;n, &amp;m);    cost.resize(n + 1), value.resize(n + 1);    w.resize(n + 1, vector&lt;ll&gt;(n + 1));    f.resize(n + 1, vector&lt;ll&gt;(mov * 2 + 5000, -INF));    for (int i = 1; i &lt;= n; ++i)        scanf(\"%lld%lld\", &amp;cost.at(i), &amp;value.at(i));    for (int i = 1; i &lt;= n; ++i)        for (int j = 1; j &lt;= n; ++j)            scanf(\"%lld\", &amp;w.at(i).at(j));    return;}ll dp() {    f.at(0).at(mov) = 0;    for (int i = 1; i &lt;= n; ++i)        for (int j = cost[i]; j &lt;= (mov&lt;&lt;1)+1; ++j)            for (int k = 0; k &lt; i; ++k)                if (f[k][j - cost[i]] != f[0][0])                    f[i][j] = max(f[i][j], f[k][j - cost[i]] + value[i] + w[k][i]);    ll ans = f[0][0];    for (int i = 0; i &lt;= n; ++i)        ans = max(ans, f.at(i).at(m + mov));    if (ans == f[0][0]) ans = -1;    return ans;}int main() {    in();    cout &lt;&lt; dp();    return 0;}\n\n华丽结束，希望能排到你的 WA 点。\n推荐一波个人博客，有着更加优秀的阅读体验。希望拥有自己个人博客的同学也可以去博客园创建。\n","categories":["题解","OI","Difficulty_4"],"tags":["动态规划","背包 DP","offset"]},{"title":"题解：P5391 [Cnoi2019] 青染之心","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP5391-Cnoi2019-%E9%9D%92%E6%9F%93%E4%B9%8B%E5%BF%83/","content":"前几篇重链剖分题解中都说或者用到了一个结论：重链剖分最多把一棵树剖分成  条链。\n那我问你，如果我祭出这张图，阁下如何应对？\n\n这个结论是错误的。而且影响很大，考场上全  一个明明可以切的题目是划不来的。仅仅是这道题目的数据允许了这样的通过。巧合而已。\n因为每个叶子节点与每条链一一映射，链的数量是和叶子节点数量持平的，而最多为  的级别（树仅仅只有根节点和叶结点）。如果是这样，那么空间复杂度又会超标。怎么办？\n可以发现对于递推数组  的使用在某一个重链递归退出后就不再使用了，因为答案已经计算出来。也就是说，每时每刻一定需要维护的  数组个数，也就是根到叶子节点经过的链数。所以如果可以动态地申请使用  数组的空间，就可以保证 ，而这个是 vector 可以做到的。\n代码如下：\n#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 20005;int q, v, ind = 0;string s;int cost[MAXN], val[MAXN];int vis[MAXN];int edgeCount;int head[MAXN], toNode[MAXN], nextEdge[MAXN];int siz[MAXN], son[MAXN];vector&lt; vector&lt;int&gt; &gt; f;int ans[MAXN];vector&lt; pair&lt;int, int&gt; &gt; era;inline void addEdge(int from, int to) {    edgeCount++;    toNode[edgeCount] = to;    nextEdge[edgeCount] = head[from];    head[from] = edgeCount;    return;}inline int read() {    int x = 0;    char ch = getchar();    while (!isdigit(ch))        ch = getchar();    while (isdigit(ch)) {        x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48);        ch = getchar();    }    return x;}inline void dfs1(int from, int father) {    siz[from]++;    for (int i = head[from]; i; i = nextEdge[i]) {        int to = toNode[i];        if (to != father) {            dfs1(to, from);            siz[from] += siz[to];            if (siz[son[from]] &lt; siz[to])                son[from] = to;        }    }    return;}inline void dfs2(int from, int father) {    for (int j = cost[from]; j &lt;= v; ++j)        f.back()[j] = max(f.back()[j], f.back()[j - cost[from]] + val[from]);    ans[from] = f.back()[v];    for (int i = head[from]; i; i = nextEdge[i]) {        int to = toNode[i];        if (to != father &amp;&amp; to != son[from]) {            f.push_back(f.back());            dfs2(to, from);            f.pop_back();        }    }    if (son[from])        dfs2(son[from], from);    return;}int main() {    q = read(), v = read();    f.push_back(vector&lt;int&gt;(v + 1, 0));    vis[0] = 20001;    for (int i = 1; i &lt;= q; ++i) {        cin &gt;&gt; s;        if (s[0] == 'a') {            addEdge(vis[ind], i);            vis[++ind] = i;            cost[i] = read(), val[i] = read();        } else            --ind, era.push_back({i, vis[ind]});    }    dfs1(vis[0], 0);    dfs2(vis[0], 0);    for (auto i : era)        ans[i.first] = ans[i.second];    for (int i = 1; i &lt;= q; ++i)        cout &lt;&lt; ans[i] &lt;&lt; '\\n';    return 0;}\n\n花絮：\n\n本来想要卡常卡进最优解的，结果偶遇知识型问题，拼尽全力无法战胜，vector 常数直接破碎了这个想法。\ndfs2 函数中使用参数  用于记录经过的重链个数，就可以搭配数组使用，因为进行了重复利用，而不是对于每一个子链进行重新分配。（详情可以见我的最优解，就是滚动数组重复利用实现的）\n用 vector 一定要先初始化不为 empty，否则取出 .back() 的时候就老实了。\n如果根节点是  的话， 一定要进行非  初始化。\n\n","categories":["题解","OI","Difficulty_6"],"tags":["动态规划","图论","动态规划优化","建模","树链剖分","背包 DP","滚动数组"]},{"title":"题解：P5994 [PA 2014] Kuglarz","url":"/2025/08/09/%E9%A2%98%E8%A7%A3%EF%BC%9AP5994-PA-2014-Kuglarz/","content":"若已知  各自的球数奇偶性，其差距 ，且奇偶性在加法运算上表现为异或，同时同起点区间查  是前缀和，则可用已知确定  位置是否有球。\n由异或前缀和，易得 ，这意味着所需的  可以通过其他已有的关系间接推导出来。这种间接的关系显然地构成了一张图：\n\n点是杯子序号；\n边是已知信息  奇偶性；\n边权是实现这个推导所需信息的代价；\n连通性是两个点经过推导的可解性，吗？\n\n那么问题来了，连通性是可解性，如何解决直接点对点查询？显然它并不连通，但是它具有可解性。怎么办？需要让特例融入一般。\n由于一般的可解性来自于对第  个点的连通性，可以想到拆点，等效于在  上安装一个给  准备的接口 ，接口与目标之间没有代价因为是人为设置的，代价在于  的连接上，这个问题就被解决了。\n注意到构成稠密图，稠密图上  的 prim 很好用，而且时间复杂度依赖点数，所以可以压缩点，把接口直接压在  上，则出现重边，根据贪心策略，g[i][i-1] = g[i-1][i] = min(read(), g[i][i-1])。注意初始化。\n小彩蛋：我们注意到输入是  级别的。\n代码：\n#include&lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int MAXN = 2005;const LL INF = 0x3f3f3f3f3f3f3f3f;int n;LL g[MAXN][MAXN];LL mst;LL dis[MAXN];bitset&lt;MAXN&gt; vis;inline LL read();inline void build() {    n = read();    for (int i = 0; i &lt;= n; ++i)        for (int j = 0; j &lt;= n; ++j)            g[i][j] = INF;    for (int i = 1; i &lt;= n; ++i) {        LL weight, u = i - 1, v;        for (int j = i; j &lt;= n; ++j) {            weight = read(), v = j;            g[u][v] = g[v][u] = min(g[u][v], weight);        }    }    return;}inline void prim() {    memset(dis, 0x3f, sizeof(dis));    dis[0] = 0;    for (int i = 0; i &lt;= n; ++i) {        LL add = 0, minDis = INF;        for (int j = 0; j &lt;= n; ++j)            if (!vis[j] &amp;&amp; dis[j] &lt; minDis)                add = j, minDis = dis[j];        mst += minDis;        vis[add] = true;        for (int j = 0; j &lt;= n; ++j)            dis[j] = min(dis[j], g[add][j]);    }    cout &lt;&lt; mst;    return;}int main() {    build();    prim();    return 0;}\n\n","categories":["题解","OI","Difficulty_6"],"tags":["图论","生成树","建模","连通性","拆点"]},{"title":"题解：P8776 [蓝桥杯 2022 省 A] 最长不下降子序列","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP8776-%E8%93%9D%E6%A1%A5%E6%9D%AF-2022-%E7%9C%81-A-%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/","content":"本蒟蒻接触 OI 半年以来的第一篇题解，不会树状数组，只好使用朴素的拼接计算的方式了。\n这是对变量名以及缩写的解释：\n\n：最长不降子序列。（Longest Not Decrease Sequence）\n：最长不升子序列。（Longest Not Increase Sequence）\n：原数组。\n：保存某一长度的最长…… 子序列的末尾值。\n：保存以某数为结尾的最长…… 子序列的长度。\n：保存以某数为开头的最长…… 子序列的长度。\n\nPart_1 dp 正确性证明显然肯定要去赋值。对于原数组的  进行子段赋值的操作，我们只需要考虑在哪两个  节点之间，并不用考虑它们之间的精确位置，所以可以特殊性地认为所选子段均在靠右的节点的正左边，为拼接操作做准备。\n（如下图，两种方案对答案并没有实质性的影响，# 表示被选。表示没有 [] 表示被赋值。）\n..#.....#...[....]...#...#..#.....#......[....]#...#\n\nPart_2 dp 策略的分析提取出一般的状态是这样的：\n....#..[....]#.... （具体个数不定）        i    j\n\n我们确定子段的最后一个下标为 ，子段后的  节点为 。\n那么当前情况的  长度应该是  且最大值不超过  的  长度  子段长度 。\n处理完之后  指针向前遍历，窗口向前滑，我们要把  纳入左半边  的考虑。\n也就是说 query 的是  位置，而 insert 的是  位置的内容。\nPart_3 dp 策略的实现在最初找  的  的时候用的方法是二分，找的是  上不超过  的位置，我们找最大值不超过  的在  上的  长度用的是相同的方法（默认会  的  等）。\n 该怎么找？老的套路很方便的可以找到 ，所以我们的方式是倒过来看，从结尾开始，截止到  的  即可。\n更多详细内容在代码的注释部分。\n#include&lt;bits/stdc++.h&gt;using namespace std;int n, k;vector&lt;int&gt; a, fend, flen, fbegin;// 本人非常喜欢用 STL :)int binSearchNotIncrease(int len, int val) {    int l = 0, r = len - 1, mid, ans = -1;    // 如果返回值为 -1 则证明没有找到 fend[mid] &lt; val    while (l &lt;= r) {        mid = (l + r) &gt;&gt; 1;        if (fend[mid] &lt; val) ans = mid, r = mid - 1;        else l = mid + 1;    }    return ans;    // 经典二分 fend[r]&lt;val fend[l]&gt;=val    // ans = mid =&gt; ans更新为目前找到的小于并且最接近val的位置}int binSearchNotDecrease(int len, int val) {    int l = 0, r = len - 1, mid, ans = -1;    while (l &lt;= r) {        mid = (l + r) &gt;&gt; 1;        if (fend[mid] &gt; val) ans = mid, r = mid - 1;        else l = mid + 1;    }    return ans;}// 同上 请自行类比理解void in() {    scanf(\"%d%d\", &amp;n, &amp;k), a.resize(n + 1);    fend.resize(n + 1), flen.resize(n + 1), fbegin.resize(n + 1);    for (int i = 0; i &lt; n; ++i)        scanf(\"%d\", &amp;a[i]);    return;}// 本人喜欢用 vector&lt;&gt; 各位 int[] 大佬见谅void calculateLNIS() {    int len = 0;    for (int i = n - 1; i &gt;= 0; --i) {        int find_ = binSearchNotIncrease(len, a[i]);        if (find_ == -1)            fend[len++] = a[i], fbegin[i] = len;        // 没有找到 =&gt; a[i]小于等于最后一个 =&gt; len++, 以 i 为开始的长度为len        else            fend[find_] = a[i], fbegin[i] = find_ + 1;        // 由于下标从 0 开始，所以为 find_ + 1        // 找到了 =&gt; 更新 fend[find_] 为 a[i], 原理与 LIS替换 相同，看不懂自行补课    }    return;}void solve() {    calculateLNIS();    // 首先计算逆序的 LNIS 准备好    int len = 0, ans = 0;    for (int i = 0, j = k, find_; j &lt; n; ++i, ++j) {        find_ = binSearchNotDecrease(len, a[j]);        // 先找 i 左边(len维护) 比 &lt;=a[j] 的 LNDS 长度，这个是查询的 j        ans = max(ans, (find_ == -1 ? len : find_) + fbegin[j] + k);        // find_ == -1 =&gt; 没有找到比 a[j] 更大的 =&gt; len 维护的左半边 LNDS长度 即为左半边长度        // 当前结果 ans 与 左半边+右半边+子段长度 求 max        find_ = binSearchNotDecrease(len, a[i]);        if (find_ == -1)            fend[len++] = a[i];        else            fend[find_] = a[i];        // 经典 insert(i)    }    ans = max(ans, len + k);    // 由于是从 LNDS 节点开始考虑的，所以还要注意一种结尾的情况    cout &lt;&lt; ans;    return;}int main() {    in();    solve();    return 0;}\n","categories":["题解","OI","Difficulty_5"],"tags":["动态规划","基础算法","二分","最长单调子序列","双指针"]},{"title":"题解：P9294 [POI 2020] Cukiernia / 糕点店","url":"/2025/08/10/%E9%A2%98%E8%A7%A3%EF%BC%9AP9294-POI-2020-Cukiernia-%E7%B3%95%E7%82%B9%E5%BA%97/","content":"P9294 [POI 2020] Cukiernia / 糕点店每个货架上有多个货物，目标是通过移动让每个货架上只有一个，每一次移动可以改变一个糕点的位置。\n货架上有没有某一种糕点非常重要，而这个不容易通过维护  实现，因为上一个货架选择保留哪一种会影响到这一层要处理哪些糕点以及其个数。这个时候可以考虑用二进制的方法去处理有或没有的组合情况：一个二进制数的前三位分别表示是否有  这样遍历  就可以处理出所有可能的情况。\n也就是说  表示的是第  个货架上，面对  情况，将整理好的状态转移给下一状态的最小代价。然后思考如何转移。假设  对应 。\n 的情况有些糕点可能是没有的，所以这个情况只有可能是其子情况推演过来。也就是说，如果  层的状态  拥有  没有的糕点并传递给了下一层 ，那么此时  层的状态不可能是 ，所以就有如下的推导：\n\n可以是上一层货架和这一层的情况是完全一致的。\n可以是上一层货架比这一层少了某一个，其有无糕点的其情况是当前情况的子情况。\n\n那么对于现在我有某一种（以  为例），所以我想丢弃我现在拥有的 ，所以上一层的情况中，其他一样，仅仅是  的存在性不同，则并不影响可行性，所以就在其中选择最优。\n我们对于每一种情况都进行这样的讨论，就可以推出状态转移了，具体见代码。同时可以使用滚动数组进行空间优化。毕竟只依赖上一层，而且是交叉依赖，所以保留两层完整的数组就足够了。\n#include&lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const ll MAXN = 300005;const ll INF = 0x3f3f3f3f3f3f3f3f;ll n, d[MAXN], p[MAXN], r[MAXN];ll type, f[2][8];void in() {    scanf(\"%lld\", &amp;n);    for (int i = 1; i &lt;= n; ++i)        scanf(\"%lld%lld%lld\", &amp;d[i], &amp;p[i], &amp;r[i]);    for (int i = 1; i &lt;= n &amp;&amp; type != 7; ++i) {        if (d[i])\ttype |= 1;        if (p[i])\ttype |= 2;        if (r[i])\ttype |= 4;    }    return;}void dp() {    for (int i = 0; i &lt; 8; ++i)        f[0][i] = f[1][i] = INF;    f[0][0] = 0;    for (int i = 1; i &lt;= n; ++i) {        ll cur = i % 2, pre = (i - 1) % 2, tot = d[i] + p[i] + r[i];        for (int j = 0; j &lt; 8; ++j) {            f[cur][j] = INF;            if (j &amp; 1)                f[cur][j] = min(f[cur][j], min(f[pre][j], f[pre][j ^ 1]) + tot - d[i]);            if (j &amp; 2)                f[cur][j] = min(f[cur][j], min(f[pre][j], f[pre][j ^ 2]) + tot - p[i]);            if (j &amp; 4)                f[cur][j] = min(f[cur][j], min(f[pre][j], f[pre][j ^ 4]) + tot - r[i]);        }    }    return;}int main() {    in();    dp();    cout &lt;&lt; f[n % 2][type];    return 0;}\n","categories":["题解","OI","Difficulty_4"],"tags":["动态规划","分类讨论","状态压缩"]},{"title":"题解：P9869 [NOIP 2023] 三值逻辑","url":"/2025/08/09/%E9%A2%98%E8%A7%A3%EF%BC%9AP9869-NOIP-2023-%E4%B8%89%E5%80%BC%E9%80%BB%E8%BE%91/","content":"扩展域并查集题解\n如果我考场上看见这个题目，肯定不会觉得和并查集有半点关系\n\n约束系统我们的目标是找到一个初始值方案 ，使得对于每个 ，都有 。\n我们分析依赖关系，推导出 ，其表达式总是以下三种形式之一：\n\n常量\n\n\n\n代入 ，得到了关于初始值的约束方程：\n\n\n\n\n\n这个推导是具有充分必要性的，也就是说，任何一个合法的初始值方案，必须满足这个由所有  条语句推导出的最终约束系统，且任何一个满足这个约束系统的赋值方案，也必然是一个合法的解。\n所以，原问题就被转化成了“找到一个初始值方案使满足这个约束系统”。也就是说，只要在满足约束系统的条件下进行关系推导，得到的解就也是合法的，我们期望得到的，就是最小化  的那一个。\n求最优解我们用并查集来分析这个约束系统。这个分析过程会把所有变量划分成若干个不相交的连通块。会有很多的操作，让我们从结果开始分析。\n什么时候是 ？\nfindAnc(x) == findAnc(x + n)，我和我的非在一个逻辑值中，那肯定是 ；\nanc[x] = U，就是在  这个集合当中，显然是 ；\n\n所以我们要维护的就是 anc 关系，并查集是可以的。\n但是注意，不能 merge，因为赋值不会影响到祖先，只会影响到自己 。那有的同学就要问了：\n\n欸？这个路径压缩是有滞后性的啊，你这么改会有问题啊？\n\n现在我们就来思考，为什么这么做是满足约束要求的。由于我们的约束关系仅仅关于初始值，中途能够合并的点的初始值都是一致的。所以我们可以在过程中绕一圈，T -&gt; F -&gt; T 这样最终回到初始值，就仍然是合法的。这说明，我们让  的子树（更新滞后仍然依赖于 ）和  一起走一遭在结果上看是没有问题的。\n代码实现有几个小细节：\n初始化正常流程，如果说最后有一些联通块并没有和  中任意一个相连，说明他们可以随便赋成某个值，在最小化  的过程中是没有贡献的，不考虑即可；\n对于  操作， 时注意用 swap；\nfindAnc 可能会有环的情况，处理如下：\n\n如果是 ，那就直接 return 对应值即可；\n我们记录 vis，表示当前 dfs 过程中路径上的值：\nvis[x + n] == true，说明 x, x + n 在同一联通块内，是 ；\nvis[x] = true，说明走回来了，是一个没有确定的祖先的独立于  的部分，返回一个非  值即可， 都行。\n\n\n\n#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 2e5 + 7;int c, t;int n, m;int a, b;string opt;int T, F, U;int anc[MAXN];bitset&lt;MAXN&gt; vis;inline void ancInit(int siz) {    for (int i = 1; i &lt;= siz; ++i)        anc[i] = i;    return;}inline int match(int x) {    if(x == T || x == U || x == F)        return x;    return (x &lt;= n) ? x + n : x - n;}inline int findAnc(int cur) {    if (cur == F || cur == T || cur == U)        return cur;    if (vis[match(cur)])        return U;    if (vis[cur])        return T;    if (cur != anc[cur]) {        vis[cur] = true;        anc[cur] = findAnc(anc[cur]);        vis[cur] = false;    }    return anc[cur];}int main() {    ios::sync_with_stdio(false);    cin.tie(nullptr);    cout.tie(nullptr);    cin &gt;&gt; c &gt;&gt; t;    while (t--) {        int ans = 0;        cin &gt;&gt; n &gt;&gt; m;        T = 2 * n + 1;        F = 2 * n + 2;        U = 2 * n + 3;        ancInit(2 * n + 3);        while (m--) {            cin &gt;&gt; opt &gt;&gt; a;            if (opt == \"T\")                anc[a] = T, anc[a + n] = F;            else if (opt == \"F\")                anc[a] = F, anc[a + n] = T;            else if (opt == \"U\")                anc[a] = anc[a + n] = U;            else {                cin &gt;&gt; b;                if (opt == \"+\") {                    anc[a] = anc[b];                    anc[a + n] = anc[b + n];                } else {                    if (a == b)                        swap(anc[a], anc[a + n]);                    else {                        anc[a + n] = anc[b];                        anc[a] = anc[b + n];                    }                }            }        }        for (int i = 1; i &lt;= n; ++i)            if (findAnc(i) == U)                ans++;        cout &lt;&lt; ans &lt;&lt; '\\n';    }    return 0;}\n","categories":["题解","OI","Difficulty_6"],"tags":["数据结构","并查集","建模","扩展域并查集"]}]